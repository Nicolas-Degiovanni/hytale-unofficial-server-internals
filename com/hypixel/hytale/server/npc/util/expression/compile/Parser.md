---
description: Architectural reference for Parser
---

# Parser

**Package:** com.hypixel.hytale.server.npc.util.expression.compile
**Type:** Transient

## Definition
```java
// Signature
public class Parser {
```

## Architecture & Concepts
The Parser is a stateful, single-use component responsible for transforming a linear string expression into a structured sequence of operations. It implements a variant of Dijkstra's Shunting-yard algorithm to convert infix notation (e.g., `a + b * c`) into a postfix, or Reverse Polish Notation (RPN), stream of tokens.

This class does not produce a direct output like an Abstract Syntax Tree (AST). Instead, it operates as a producer, pushing parsed tokens and operators to a consumer that implements the ParsedTokenConsumer interface. This design decouples the parsing logic from the code generation or evaluation logic, allowing different backends to be attached to the same parsing frontend.

The Parser sits at the core of the expression evaluation pipeline, acting as the bridge between the Lexer (which performs tokenization) and a compiler or interpreter (which consumes the RPN stream). It correctly handles operator precedence, associativity, parentheses, function calls, and tuples.

## Lifecycle & Ownership
- **Creation:** A Parser instance is created on-demand by a higher-level system, such as an expression compiler or evaluator. It is constructed with a reference to a Lexer, which it uses to tokenize the input string.

- **Scope:** The Parser object is transient and designed for a single `parse` operation. Its internal state, particularly the operator and bracket stacks, is valid only for the duration of one `parse` call. The `parse` method explicitly clears this state upon invocation, ensuring each run is isolated.

- **Destruction:** The object holds no persistent resources and is eligible for garbage collection as soon as the `parse` method completes and the caller discards the reference.

## Internal State & Concurrency
- **State:** The Parser is highly stateful and mutable. Its core state is maintained in two internal stacks: `operatorStack` and `bracketStack`. These data structures are fundamental to the Shunting-yard algorithm for tracking operators and nested contexts (like parentheses or function arguments). This state is not intended to be accessed externally and is reset at the beginning of each parsing operation.

- **Thread Safety:** This class is **not thread-safe**. The mutable internal stacks and context object make it fundamentally unsafe for concurrent use. Any attempt to call the `parse` method from multiple threads on a shared instance will result in severe state corruption and unpredictable behavior.

**WARNING:** Each thread requiring expression parsing capabilities must create and use its own dedicated Parser instance. Do not share instances across threads.

## API Surface
The public contract is minimal, exposing only the primary parsing functionality.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| parse(expression, tokenConsumer) | void | O(n) | Parses the given string expression. Iterates through the entire string once. Throws ParseException on syntax errors. |
| peekOperator() | ParsedToken | O(1) | Returns the operator at the top of the internal operator stack without removing it. Primarily for internal or advanced consumer use. |

## Integration Patterns

### Standard Usage
The Parser must be provided with a Lexer at construction and a ParsedTokenConsumer during the `parse` call. The consumer is responsible for building the final output structure from the RPN stream generated by the Parser.

```java
// 1. Obtain a Lexer instance
Lexer<Token> lexer = new ExpressionLexer();

// 2. Instantiate the Parser
Parser parser = new Parser(lexer);

// 3. Implement a consumer to build the desired output (e.g., an AST or bytecode)
// This is a conceptual example.
ExpressionBuilderConsumer consumer = new ExpressionBuilderConsumer();

// 4. Execute the parse operation
try {
    parser.parse("2 * (player.health + 5)", consumer);
    // The 'consumer' now holds the result of the parse
    Expression finalExpression = consumer.getResult();
} catch (ParseException e) {
    // Handle syntax errors
}
```

### Anti-Patterns (Do NOT do this)
- **Instance Reuse Across Threads:** Never share a single Parser instance between multiple threads. This will lead to race conditions and corrupt the internal stacks.
- **State Inspection:** Do not rely on inspecting the internal state of the Parser via `peekOperator` for primary application logic. The class is designed to be a black box that pushes data to a consumer.
- **Ignoring ParseException:** Failing to catch ParseException will result in unhandled exceptions for malformed expressions. All calls to `parse` must be wrapped in a try-catch block.

## Data Pipeline
The Parser is a key transformation stage in the data flow from a raw string to an executable representation.

> Flow:
> String Expression -> **Lexer** -> Stream of Tokens -> **Parser** (Shunting-yard Transformation) -> Calls to **ParsedTokenConsumer** -> Final Representation (AST, Bytecode, etc.)


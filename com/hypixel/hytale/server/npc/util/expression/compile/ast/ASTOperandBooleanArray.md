---
description: Architectural reference for ASTOperandBooleanArray
---

# ASTOperandBooleanArray

**Package:** com.hypixel.hytale.server.npc.util.expression.compile.ast
**Type:** Transient

## Definition
```java
// Signature
public class ASTOperandBooleanArray extends ASTOperand {
```

## Architecture & Concepts
The ASTOperandBooleanArray is a leaf node within an Abstract Syntax Tree (AST) generated by the server-side NPC expression compiler. Its sole purpose is to represent a compile-time constant value: an array of booleans.

This class acts as a structural data container during the compilation pipeline. It is created by the Parser when it encounters a boolean array literal (e.g., `[true, false, true]`) or a predefined constant identifier that resolves to a boolean array.

Crucially, this node is not just a data holder; it embodies the "knows how to compile itself" pattern. The `codeGen` field contains the logic to translate its internal state directly into a `PUSH` instruction for the expression's virtual machine, the ExecutionContext. It forms a critical link between the static source code representation and the dynamic, executable bytecode.

## Lifecycle & Ownership
- **Creation:** Instantiated exclusively by the expression language *Parser* during the syntax analysis phase. The Parser will choose a constructor based on whether it is parsing an array literal from scratch or resolving a named constant from the current Scope.
- **Scope:** Ephemeral. An instance of ASTOperandBooleanArray exists only for the duration of a single expression compilation. It is a temporary object used to build the complete AST.
- **Destruction:** The entire AST, including all its nodes, becomes eligible for garbage collection immediately after the Code Generator has traversed it to produce the final bytecode. It holds no external references and is not intended to outlive the compilation process.

## Internal State & Concurrency
- **State:** Immutable. The core state, `constantBoolArray`, is a final field initialized at construction. The object provides no methods to mutate this array. Its identity as a constant is programmatically enforced by the `isConstant()` method, which always returns true.
- **Thread Safety:** Inherently thread-safe. As an immutable value object, it can be safely read from multiple threads without any need for locks or synchronization. This would allow for parallel processing of ASTs, should the compiler architecture support it.

## API Surface
The public API is minimal, reflecting its role as an internal data structure for the compiler.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| isConstant() | boolean | O(1) | Confirms that the node represents a compile-time constant. Always returns true. |
| asOperand() | ExecutionContext.Operand | O(1) | Wraps the internal boolean array into a runtime operand for the execution engine. |

## Integration Patterns

### Standard Usage
This class is not intended for direct use by developers. It is an internal component of the expression compiler. The following conceptual example illustrates its role during code generation.

```java
// Conceptual usage within a hypothetical CodeGenerator class

void visit(ASTOperandBooleanArray node) {
    // The node's codeGen lambda is invoked to produce the bytecode.
    // This typically generates a PUSH instruction to place the
    // constant boolean array onto the execution stack.
    Bytecode instruction = node.codeGen.generate(currentScope);
    bytecodeStream.add(instruction);
}
```

### Anti-Patterns (Do NOT do this)
- **Direct Instantiation:** Never create an instance of ASTOperandBooleanArray manually. It must be produced by the expression parser to ensure the integrity of the AST.
- **Representing Variables:** Do not attempt to use this class for arrays that change at runtime. It is strictly for compile-time constants. The constructor logic will throw an `IllegalArgumentException` if you attempt to bind it to a non-constant identifier from a Scope.

## Data Pipeline
ASTOperandBooleanArray is a key stage in the transformation of source text into executable instructions.

> Flow:
> Expression String -> Tokenizer -> Parser -> **AST Tree (containing ASTOperandBooleanArray nodes)** -> Code Generator -> ExecutionContext Bytecode

---


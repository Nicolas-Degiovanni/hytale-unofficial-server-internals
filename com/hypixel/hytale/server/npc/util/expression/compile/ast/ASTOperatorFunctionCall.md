---
description: Architectural reference for ASTOperatorFunctionCall
---

# ASTOperatorFunctionCall

**Package:** com.hypixel.hytale.server.npc.util.expression.compile.ast
**Type:** Transient Node

## Definition
```java
// Signature
public class ASTOperatorFunctionCall extends ASTOperator {
```

## Architecture & Concepts
The ASTOperatorFunctionCall is a structural node within the Abstract Syntax Tree (AST) generated by the server's expression language compiler. It represents a direct invocation of a named function, such as `CalculateHealth(10, 20)`. This class is a pivotal component in the transition from parsed tokens to executable bytecode.

Its primary role is to encapsulate a function call, its resolved arguments (which are themselves AST sub-trees), and the logic required to generate a `CALL` instruction for the Expression `ExecutionContext` virtual machine.

A critical architectural concept implemented by this class and its factory method is **function signature mangling**. The internal `functionName` field does not store the simple, human-readable name of the function. Instead, it stores a decorated or "mangled" name that includes the encoded types of its arguments, for example, `CalculateHealth@IntInt`. This mechanism is fundamental to the expression engine's support for function overloading, allowing multiple functions with the same name to be resolved correctly based on their argument types at compile time.

Furthermore, this component participates in **compile-time constant folding**. If the compiler determines that a function call and all of its arguments are constant, the `fromParsedFunction` factory will execute the function *during compilation* and replace the entire function call node with a simple `ASTOperand` containing the result. This optimization avoids runtime overhead for deterministic function calls.

## Lifecycle & Ownership
- **Creation:** Instances are created exclusively by the static factory method `fromParsedFunction`. This method is invoked by the expression parser (specifically, the `CompileContext`) when it reduces a sequence of tokens corresponding to a function identifier, parentheses, and arguments. Direct instantiation is an anti-pattern and will result in incorrect behavior.

- **Scope:** The lifetime of an ASTOperatorFunctionCall instance is strictly confined to the compilation phase of a single expression. It exists transiently on the `CompileContext` operand stack before being integrated as a child node into the broader AST.

- **Destruction:** The node is dereferenced and becomes eligible for garbage collection as soon as the compiler has traversed the AST to generate the final bytecode sequence. It holds no state that persists beyond the compilation routine.

## Internal State & Concurrency
- **State:** An instance of ASTOperatorFunctionCall is effectively immutable after its construction within the `fromParsedFunction` factory. Its mangled name, return type, and list of argument nodes are finalized during creation and are not intended to be modified thereafter. The class itself is stateless; all contextual information required for its operation is provided by the `CompileContext`.

- **Thread Safety:** The expression compilation pipeline is not thread-safe. All AST nodes, including ASTOperatorFunctionCall, are manipulated within a single-threaded context managed by the `CompileContext`. Concurrent access to or modification of this object from multiple threads will lead to a corrupted compiler state and is strictly forbidden.

## API Surface
The primary public contract is the static factory method. The constructor and other instance methods are effectively internal to the compilation package.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| fromParsedFunction(int, CompileContext) | static void | O(N) | **(Primary Entry Point)** Factory method that consumes a function identifier and N arguments from the compiler's operand stack. It performs type resolution, name mangling, and either creates an ASTOperatorFunctionCall node or performs constant folding. Throws ParseException or IllegalStateException on resolution failure. |
| isConstant() | boolean | O(1) | Returns `false`. This signals to the compiler that a function call should not be treated as a constant value by default, forcing evaluation logic into the `fromParsedFunction` factory. |

## Integration Patterns

### Standard Usage
A developer will never interact with this class directly. It is an internal implementation detail of the expression compilation engine. The engine's parser invokes it automatically when processing function call syntax.

The following pseudo-code illustrates the compiler's internal usage:

```java
// This is a conceptual representation of the compiler's logic.
// Do not use this class directly.

// 1. Parser identifies a function call with 2 arguments.
int argumentCount = 2;
CompileContext context = getActiveCompilerContext();

// 2. It invokes the factory to process the items on its internal stack.
ASTOperatorFunctionCall.fromParsedFunction(argumentCount, context);

// 3. The factory replaces the function identifier and its arguments on the
//    stack with a single ASTOperatorFunctionCall node or a constant result.
```

### Anti-Patterns (Do NOT do this)
- **Direct Instantiation:** Never call `new ASTOperatorFunctionCall()`. This bypasses the essential name mangling, type resolution, and constant folding logic handled by the `fromParsedFunction` factory, leading to runtime errors or incorrect function dispatch.

- **State Mutation:** Do not attempt to modify an ASTOperatorFunctionCall node after it has been created. The AST is considered immutable once constructed, and altering it can corrupt the bytecode generation process.

## Data Pipeline
ASTOperatorFunctionCall acts as a key transformation stage within the expression compiler's data pipeline. It converts a flat sequence of parsed operands into a hierarchical tree node representing a function invocation.

> Flow:
> Raw Expression String -> Tokenizer -> Parser (using `CompileContext` operand stack) -> **ASTOperatorFunctionCall.fromParsedFunction** -> AST Node on Stack -> Final AST -> Bytecode Generator -> Executable Instruction List


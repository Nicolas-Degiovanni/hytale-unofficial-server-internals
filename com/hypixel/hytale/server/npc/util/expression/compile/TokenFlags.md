---
description: Architectural reference for TokenFlags
---

# TokenFlags

**Package:** com.hypixel.hytale.server.npc.util.expression.compile
**Type:** Utility

## Definition
```java
// Signature
public enum TokenFlags {
```

## Architecture & Concepts
TokenFlags is a compile-time enumeration that serves as a classification system for lexical tokens within the server's expression compilation pipeline. It is not a dynamic component but rather a foundational, static utility that provides metadata about each token generated by the lexer.

During the parsing of NPC behavior expressions, raw strings are broken down into a stream of tokens. Each token is tagged with one or more flags from this enum. The parser then uses these flags to determine the token's nature—whether it is a value, an operation, a structural element like a bracket, or a hint about associativity—without needing to inspect the token's raw value. This design decouples the parser's logic from the specific syntax, allowing for a more robust and maintainable expression engine.

In essence, TokenFlags acts as the "type system" for the token stream, enabling the compiler to build an Abstract Syntax Tree (AST) correctly.

## Lifecycle & Ownership
- **Creation:** As a Java enum, TokenFlags constants are instantiated by the JVM during class loading. This process is automatic and occurs once when the TokenFlags class is first referenced.
- **Scope:** The enum and its constants are static and exist for the entire lifetime of the application. They are effectively global singletons managed by the JVM.
- **Destruction:** The constants are garbage collected only when the defining ClassLoader is unloaded, which typically happens only upon application shutdown.

## Internal State & Concurrency
- **State:** Enum constants are immutable by language design. Their state is fixed at compile time and cannot be altered at runtime.
- **Thread Safety:** TokenFlags is inherently thread-safe. Its constants can be accessed and compared from any thread without synchronization, as they are immutable and globally accessible.

## API Surface
The public API consists solely of the enum constants themselves, which represent distinct classifications for a token.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| OPERAND | Enum Constant | O(1) | Marks a token that represents a value or variable. |
| LITERAL | Enum Constant | O(1) | A specialization of OPERAND, marking a token as a hardcoded value (e.g., a number or string). |
| OPERATOR | Enum Constant | O(1) | Marks a token that represents an operation (e.g., +, -, *). |
| RIGHT_TO_LEFT | Enum Constant | O(1) | A modifier for an OPERATOR, indicating right-to-left associativity (e.g., exponentiation). |
| UNARY | Enum Constant | O(1) | A modifier for an OPERATOR, indicating it is a unary operation (e.g., logical NOT). |
| OPENING_BRACKET | Enum Constant | O(1) | Marks a token that begins a grouping expression (e.g., `(`). |
| CLOSING_BRACKET | Enum Constant | O(1) | Marks a token that ends a grouping expression (e.g., `)`). |
| LIST | Enum Constant | O(1) | Marks a token that acts as a separator within a list or function arguments (e.g., `,`). |
| OPENING_TUPLE | Enum Constant | O(1) | Marks a token that begins a tuple or list structure (e.g., `[`). |

## Integration Patterns

### Standard Usage
TokenFlags are intended to be used within the parser's logic, typically in switch statements or conditional checks, to drive the Shunting-yard algorithm or a similar AST construction process. A token object would hold a set of these flags.

```java
// Hypothetical parser logic
Token currentToken = tokenizer.getNextToken();

if (currentToken.hasFlag(TokenFlags.OPERAND)) {
    // Push to value stack
    valueStack.push(currentToken.getValue());
} else if (currentToken.hasFlag(TokenFlags.OPERATOR)) {
    // Process operator based on precedence and associativity
    handleOperator(currentToken);
}
```

### Anti-Patterns (Do NOT do this)
- **Ordinal Comparison:** Never rely on the `ordinal()` value of the enum constants for logic. The declaration order can change, which would break any logic based on `token.getFlag().ordinal() > 3`. Always compare constants directly (e.g., `flag == TokenFlags.OPERATOR`).
- **Misinterpretation:** Do not assume flags are mutually exclusive unless the compiler logic enforces it. A token could potentially be both an OPERATOR and UNARY. The consuming code must handle flag combinations correctly.

## Data Pipeline
TokenFlags is a critical component in the transformation of raw text into an executable structure. It provides the semantic metadata necessary for the parser to function.

> Flow:
> Raw String Expression -> Lexer -> Token Stream (each with **TokenFlags**) -> Parser (AST Builder) -> Abstract Syntax Tree


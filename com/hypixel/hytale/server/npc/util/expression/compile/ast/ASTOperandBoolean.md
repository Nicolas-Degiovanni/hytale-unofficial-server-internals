---
description: Architectural reference for ASTOperandBoolean
---

# ASTOperandBoolean

**Package:** com.hypixel.hytale.server.npc.util.expression.compile.ast
**Type:** Data Structure / AST Node

## Definition
```java
// Signature
public class ASTOperandBoolean extends ASTOperand {
```

## Architecture & Concepts
The ASTOperandBoolean is a leaf node within the Abstract Syntax Tree (AST) generated by the expression language compiler. It serves a single, critical purpose: to represent a compile-time constant boolean value, either *true* or *false*.

This class is a fundamental component of the compiler's front-end. During the parsing phase, when a boolean literal or a constant identifier resolving to a boolean is encountered in the source expression, an instance of ASTOperandBoolean is created to represent it in the tree.

Its primary architectural function is to bridge the gap between the parsed source text and the generated executable code. It holds the static boolean value and exposes a code generation lambda, *codeGen*, which translates this value into a low-level instruction for the expression's virtual machine, the ExecutionContext. By design, it is immutable and always represents a constant, enabling aggressive compile-time optimizations such as constant folding.

## Lifecycle & Ownership
- **Creation:** Instantiated exclusively by the expression language *Parser* during the syntactic analysis phase. It is never created by application-level logic.
- **Scope:** The lifetime of an ASTOperandBoolean instance is transient and strictly confined to the compilation of a single expression. It exists only as long as the AST is held in memory for processing.
- **Destruction:** The object is eligible for garbage collection as soon as the code generation phase is complete and the reference to the root of the AST is released. It does not persist into the runtime environment; its value is embedded directly into the generated bytecode.

## Internal State & Concurrency
- **State:** Immutable. The internal state, *constantBool*, is a final field set once at construction. All methods are pure functions that read this state without modification.
- **Thread Safety:** This class is inherently thread-safe due to its immutability. An instance can be safely accessed by multiple threads without any external synchronization. In practice, its usage is typically confined to a single compilation thread.

## API Surface
The public API is minimal, reflecting its role as a simple data holder for the compiler.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| getBoolean() | boolean | O(1) | Returns the compile-time boolean value this node represents. |
| isConstant() | boolean | O(1) | Confirms that this node represents a compile-time constant. Always returns true. |
| asOperand() | ExecutionContext.Operand | O(1) | Converts the node into a runtime operand wrapper, typically for debugging or interpretation. |

## Integration Patterns

### Standard Usage
This class is an internal component of the expression compiler and is not intended for direct use by developers. Its integration is handled entirely by the compiler's internal machinery. The following conceptual example illustrates how a parser might create it.

```java
// Conceptual example within a hypothetical Parser class
// This code does not exist but illustrates the pattern.

Token currentToken = consumeToken(); // e.g., a token for "true"
if (currentToken.isBooleanLiteral()) {
    boolean value = parseBoolean(currentToken.getText());
    ASTNode node = new ASTOperandBoolean(currentToken, currentToken.getPosition(), value);
    // ...add node to the AST...
}
```

### Anti-Patterns (Do NOT do this)
- **Direct Instantiation:** Never create an instance of ASTOperandBoolean directly in application code. The expression compiler is the sole owner and creator of AST nodes. Manual creation bypasses the parsing and validation logic, leading to an invalid AST.
- **Representing Variables:** Do not attempt to use this class for a value that can change at runtime. It is strictly for compile-time constants. The constructor that accepts an identifier will throw an IllegalArgumentException if the identifier does not resolve to a constant value in the provided Scope.

## Data Pipeline
ASTOperandBoolean is a key checkpoint in the data flow from raw source text to executable instructions.

> Flow:
> Source Text (`"isAlive == true"`) -> Tokenizer -> Token (`TRUE`) -> Parser -> **ASTOperandBoolean** -> CodeGenerator -> ExecutionContext Bytecode (`PUSH true`)


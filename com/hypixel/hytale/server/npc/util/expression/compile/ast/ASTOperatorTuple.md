---
description: Architectural reference for ASTOperatorTuple
---

# ASTOperatorTuple

**Package:** com.hypixel.hytale.server.npc.util.expression.compile.ast
**Type:** Transient

## Definition
```java
// Signature
public class ASTOperatorTuple extends ASTOperator {
```

## Architecture & Concepts
The **ASTOperatorTuple** is an Abstract Syntax Tree (AST) node representing a non-constant array constructor within the server-side NPC expression language. It is generated by the **Parser** when it encounters tuple syntax, for example `[1, myVariable, 3]`, where at least one element is not a compile-time constant.

This class acts as an intermediate representation of an operation, not a final value. Its primary responsibility is to generate the `PACK` virtual machine instruction via its `codeGen` lambda. This instruction, when executed by the **ExecutionContext**, will pop a specified number of values from the stack and package them into a new array at runtime.

A critical design choice in the compiler is the separation of constant and non-constant arrays. If the **Parser** determines that all elements within a tuple are constants (e.g., `[1, 2, 3]`), it will bypass **ASTOperatorTuple** entirely and instead create a more efficient **ASTOperand...Array** node (e.g., **ASTOperandNumberArray**). This optimization pre-computes the array at compile time, avoiding runtime overhead. Therefore, the existence of an **ASTOperatorTuple** node in a compiled tree explicitly signifies a dynamic array creation.

## Lifecycle & Ownership
- **Creation:** An **ASTOperatorTuple** is instantiated exclusively by the static factory method `fromParsedTuple`. This method is invoked internally by the **Parser** during the Shunting-yard algorithm execution when a closing square bracket token is processed and the contained elements are determined to be non-constant.
- **Scope:** The object's lifetime is strictly confined to the compilation process. It exists as a node within the AST held by the **CompileContext**. Once the final AST is constructed and returned, this node becomes a permanent, immutable part of that tree structure.
- **Destruction:** The object is eligible for garbage collection when the AST it belongs to is discarded. This typically occurs when a script or behavior is unloaded by the server.

## Internal State & Concurrency
- **State:** The object is stateful but effectively immutable after construction. During its creation within the `fromParsedTuple` method, child AST nodes (its arguments) are added to it. Once it is pushed onto the **CompileContext** operand stack, its internal list of arguments is never modified.
- **Thread Safety:** **This class is not thread-safe.** The entire expression compilation pipeline, including the **CompileContext** and its associated stacks, is designed for single-threaded access. Concurrent modification of the operand stack during this node's creation would lead to heap corruption and indeterminate compiler behavior.

**WARNING:** Do not access or manipulate AST nodes from multiple threads during the compilation phase.

## API Surface
The primary public contract is the static factory method used by the compiler. Instance methods are internal to the AST processing system.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| fromParsedTuple(token, argCount, context) | static void | O(N) | Factory method. Analyzes the top N items on the operand stack and constructs either a constant **ASTOperand...Array** or a dynamic **ASTOperatorTuple**. Throws **IllegalStateException** on type mismatch. |
| isConstant() | boolean | O(1) | Overridden to always return **false**, signifying that this node represents a runtime operation. |

## Integration Patterns

### Standard Usage
A developer using the expression engine will never interact with this class directly. Its usage is entirely encapsulated within the **Parser**. The following conceptual example illustrates how the compiler invokes it.

```java
// This code is illustrative of the Parser's internal logic.
// Do not replicate this pattern.

// Assume the parser has just processed "[a, b, c]"
Parser.ParsedToken openingBracket = ...;
int argumentCount = 3;
CompileContext context = ...; // Contains the operand stack with AST nodes for a, b, c

// The Parser invokes the factory to create the appropriate AST node
ASTOperatorTuple.fromParsedTuple(openingBracket, argumentCount, context);

// The operand stack in the context now contains a single ASTOperatorTuple
// node representing the array creation.
```

### Anti-Patterns (Do NOT do this)
- **Direct Instantiation:** The constructor is not public. All creation is managed by the static `fromParsedTuple` factory to ensure the correct compile-time optimizations are applied.
- **External Invocation:** Do not call `fromParsedTuple` from outside the expression compilation pipeline. It relies on the specific state of the **CompileContext** and its operand stack, and calling it directly will corrupt the compiler state.
- **Post-Compilation Modification:** Attempting to modify an **ASTOperatorTuple** node (e.g., by adding more arguments) after the AST has been built is an unsupported operation and will lead to undefined behavior during execution.

## Data Pipeline
The **ASTOperatorTuple** is a key component in the transformation of source text into executable bytecode.

> **Compilation Flow:**
> Expression String -> **Parser** (with **CompileContext**) -> `fromParsedTuple` static call -> **ASTOperatorTuple** instance -> Pushed to Operand Stack -> Final AST

> **Execution Flow:**
> AST Interpreter visits **ASTOperatorTuple** node -> `codeGen` lambda is executed -> `ExecutionContext.genPACK` is called -> `PACK` bytecode is emitted -> VM creates array at runtime


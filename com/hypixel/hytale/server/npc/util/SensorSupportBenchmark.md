---
description: Architectural reference for SensorSupportBenchmark
---

# SensorSupportBenchmark

**Package:** com.hypixel.hytale.server.npc.util
**Type:** Transient

## Definition
```java
// Signature
public class SensorSupportBenchmark {
```

## Architecture & Concepts
The SensorSupportBenchmark class is a specialized, high-performance data aggregator used for profiling the server-side NPC sensor system. It is not part of the core game simulation logic; instead, it functions as a passive measurement and reporting tool.

Its primary architectural role is to act as a data sink for performance metrics generated by NPC sensing operations, such as searching for players, finding entities, and performing line-of-sight (LoS) checks. Various components within the NPC AI pipeline push raw timing, distance, and count data into this object during a game tick. The class then aggregates this data over time using a collection of specialized `TimeRecorder` and `ValueRecorder` objects.

At the end of each tick, the `tickDone` method is invoked to finalize the measurements for that frame, rolling up temporary counters into long-term statistical accumulators. The class also provides a suite of `format` methods to render the collected performance data into a human-readable, tabular text format for display in server logs or debug consoles.

## Lifecycle & Ownership
- **Creation:** An instance of SensorSupportBenchmark is typically created and owned by a higher-level debugging or profiling manager when NPC sensor analysis is required. It is not a managed service and is instantiated directly via its constructor.
- **Scope:** The object is designed to be long-lived, persisting across many game ticks to accumulate meaningful statistical data. Its lifetime is bound to the duration of the profiling session, which may be the entire server session if benchmarking is enabled by default.
- **Destruction:** The object holds no external resources and is cleaned up by the Java garbage collector once the owning profiling system releases its reference. There is no explicit destruction or cleanup method.

## Internal State & Concurrency
- **State:** This class is highly stateful and mutable. Its core function is to accumulate performance data within its internal `TimeRecorder` and `DiscreteValueRecorder` fields. The state represents a running statistical summary of sensor performance over time.
- **Thread Safety:** **This class is not thread-safe.** All methods perform unsynchronized writes to instance fields. It is architecturally bound to the single-threaded server game loop.

    **Warning:** Concurrent invocation of any method, particularly the `collect` and `tickDone` methods, from multiple threads will result in data corruption, race conditions, and non-deterministic profiling results. All interactions with an instance of this class must be serialized and confined to the main server thread.

## API Surface
The public API is divided into two primary categories: data collection and data formatting.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| collectPlayerList(...) | void | O(1) | Records performance metrics for a player search operation. |
| collectEntityList(...) | void | O(1) | Records performance metrics for a generic entity search operation. |
| collectLosTest(...) | void | O(1) | Records a line-of-sight test, its execution time, and cache hit status. |
| tickDone() | void | O(1) | Finalizes and commits the performance data collected during the current game tick. |
| formatValuesUpdateTimePlayer(...) | void | O(1) | Formats the aggregated player search metrics into a provided Formatter. |
| formatValuesLoS(...) | boolean | O(1) | Formats the aggregated line-of-sight metrics into a provided Formatter. |

## Integration Patterns

### Standard Usage
The intended pattern involves creating a single instance and reusing it over the lifetime of the server or profiling session. Data is collected during the NPC update phase, and `tickDone` is called once per game tick.

```java
// During initialization of a profiling system
SensorSupportBenchmark benchmark = new SensorSupportBenchmark();

// --- In the main server game loop, during NPC sensor updates ---
// Example: After querying for nearby players
benchmark.collectPlayerList(queryTimeNanos, maxDistSorted, maxDist, maxDistAvoid, count);

// Example: After a line-of-sight check
benchmark.collectLosTest(wasCacheHit, losCheckTimeNanos);

// --- At the end of the server game tick ---
benchmark.tickDone();

// --- When a report is requested (e.g., via a command) ---
StringBuilder sb = new StringBuilder();
Formatter formatter = new Formatter(sb);
benchmark.formatHeaderUpdateTimes(formatter);
sb.append('\n');
benchmark.formatValuesUpdateTimePlayer(formatter);
System.out.println(sb.toString());
```

### Anti-Patterns (Do NOT do this)
- **Instance-per-Tick:** Do not create a new `SensorSupportBenchmark` for each game tick. This defeats the purpose of statistical aggregation over time and will result in meaningless data.
- **Asynchronous Access:** Do not call any methods on this class from other threads, such as network or worker threads. All calls must originate from the main server thread to prevent data corruption.
- **Skipping `tickDone`:** Failure to call `tickDone` at the end of each tick where data was collected will cause per-tick counters to bleed into subsequent ticks, invalidating all line-of-sight and cache hit metrics.

## Data Pipeline
The flow of data through this component is linear and synchronous, serving as a terminal point for performance metrics within a single game tick.

> Flow:
> NPC Sensor Logic -> Raw Performance Data (Timings, Distances, Counts) -> `collect...()` Methods -> **Internal Per-Tick Counters & Recorders** -> `tickDone()` -> Aggregated Statistical State -> `format...()` Methods -> Formatted String Report


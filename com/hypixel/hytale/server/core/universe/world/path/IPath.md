---
description: Architectural reference for the IPath interface, the core contract for defining sequential routes in the game world.
---

# IPath

**Package:** com.hypixel.hytale.server.core.universe.world.path
**Type:** Contract / Interface

## Definition
```java
// Signature
public interface IPath<Waypoint extends IPathWaypoint> {
```

## Architecture & Concepts
The **IPath** interface is a foundational contract within the server's world representation. It serves as an abstract definition for a sequence of points, or waypoints, that form a navigable route. This interface is not a concrete system but rather a data-oriented contract used by various higher-level systems, such as AI navigation, quest scripting, and cinematic event triggers.

Its primary architectural role is to decouple path-following logic (e.g., an NPC's movement controller) from path-generation logic (e.g., an A* pathfinding algorithm). By programming against this interface, an entity can traverse a path without needing to know how that path was created, whether it was pre-defined by a designer or dynamically calculated at runtime.

The use of a generic parameter, **Waypoint extends IPathWaypoint**, is a critical design choice. It allows for polymorphism in path composition. A simple path might use waypoints that only contain coordinates, while a more complex quest-related path could use waypoints containing additional metadata such as required actions, trigger volumes, or movement speed modifiers.

## Lifecycle & Ownership
As an interface, **IPath** itself has no lifecycle. The lifecycle and ownership semantics apply to the concrete classes that implement this contract.

- **Creation:** Instances implementing **IPath** are typically generated by factory or service classes. Common creators include the **PathfindingService** (for dynamic paths) or a **WorldDataManager** that deserializes pre-authored paths from world files.
- **Scope:** The lifetime of an **IPath** object is bound to its owner. A path generated for a single NPC task may be short-lived and garbage collected after the task is complete. A path defining a major patrol route for a city guard may be loaded with the zone and persist until the zone is unloaded.
- **Destruction:** Ownership is explicit. The system that requested or loaded the path is responsible for releasing its reference, allowing for garbage collection. There is no explicit `destroy` or `close` method in the contract.

## Internal State & Concurrency
The **IPath** contract strongly implies immutability. There are no methods for mutation, such as `addWaypoint` or `setName`. All methods are accessors.

- **State:** The state is defined by its identifier, name, and the ordered list of waypoints. Implementations are expected to be immutable or, at a minimum, behave as if they are once handed to a consumer.
- **Thread Safety:** The contract is inherently safe for concurrent reads. Any class implementing **IPath** **MUST** be thread-safe for all read operations. Modifying the list returned by `getPathWaypoints` is an unsupported operation and will lead to undefined behavior.

**WARNING:** Consumers must treat the **List** returned by `getPathWaypoints` as read-only. Modifying this collection may corrupt the state of the path for all other systems using it.

## API Surface
The public contract consists entirely of non-blocking, idempotent accessor methods.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| getId() | UUID | O(1) | Returns the unique identifier for this path, if one exists. May be null for transient paths. |
| getName() | String | O(1) | Returns the human-readable name of the path, often used for debugging or tooling. May be null. |
| getPathWaypoints() | List<Waypoint> | O(1) | Returns the complete, ordered list of waypoints. See concurrency warnings. |
| length() | int | O(1) | Returns the total number of waypoints in the path. |
| get(int index) | Waypoint | O(1) | Retrieves the waypoint at the specified index. Throws IndexOutOfBoundsException if the index is invalid. |

## Integration Patterns

### Standard Usage
An **IPath** is typically consumed by a path-following or navigation system. The consumer iterates through the waypoints to guide an entity or process.

```java
// A path is acquired from a service, not created directly.
IPath<SimpleWaypoint> route = pathfindingService.findPath(startPos, endPos);

if (route != null && route.length() > 0) {
    // An NPC controller iterates the path to move the entity.
    for (int i = 0; i < route.length(); i++) {
        SimpleWaypoint nextStop = route.get(i);
        npc.getMovementController().moveTo(nextStop.getPosition());
    }
}
```

### Anti-Patterns (Do NOT do this)
- **Casting to Concrete Types:** Do not cast an **IPath** instance to a specific implementation (e.g., **AStarPath**). All logic should rely solely on the methods defined in the **IPath** and **IPathWaypoint** interfaces to maintain system decoupling.
- **Modifying Returned Collections:** The list from `getPathWaypoints` should never be modified. This violates the immutability contract and can cause severe, difficult-to-trace bugs in other systems that share the same path instance.
- **Assuming Path Existence:** Always check if a path is null or has a length of zero before attempting to access its waypoints. Pathfinding can fail, and services will return a null or empty path in those cases.

## Data Pipeline
**IPath** is not a processing component but rather a data product that flows between systems. It is the output of a generation process and the input to a consumption process.

> Flow:
> Path Request (e.g., Start/End Coordinates) -> **PathfindingService** -> Generates concrete **IPath** instance -> **NPC Behavior Tree** -> Consumes **IPath** to update entity state -> **Entity Movement System**


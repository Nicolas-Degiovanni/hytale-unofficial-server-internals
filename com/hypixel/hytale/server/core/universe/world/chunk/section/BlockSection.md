---
description: Architectural reference for BlockSection
---

# BlockSection

**Package:** com.hypixel.hytale.server.core.universe.world.chunk.section
**Type:** Component

## Definition
```java
// Signature
public class BlockSection implements Component<ChunkStore> {
```

## Architecture & Concepts
The BlockSection is the fundamental data structure representing a 32x32x32 cubic volume of blocks within a world chunk. It is the atomic unit for block storage, lighting, and scheduled block updates on the server. A vertical `BlockChunk` is composed of multiple BlockSection instances, stacked vertically to form a complete column from the bottom to the top of the world.

This class is not merely a data container; it is an active component in the world simulation engine. Its design is heavily optimized for memory efficiency and high-concurrency access patterns typical of a multiplayer game server.

The core storage mechanism is built upon a **palette-based system** via the ISectionPalette interface. Instead of storing the full identifier for each of the 32,768 blocks, a BlockSection maintains a small, unique list of block types present within it (the palette). The main data array then stores only the compact indices into this palette. This strategy dramatically reduces the memory and disk footprint for sections with low block diversity, such as those composed primarily of air, stone, or water.

Data is segregated into three distinct palettes for architectural clarity and efficiency:
*   **chunkSection:** The primary palette for base block types.
*   **fillerSection:** A secondary palette for storing complex block metadata, such as the orientation of grass blocks relative to their dirt source.
*   **rotationSection:** A dedicated palette for storing the rotational state (yaw, pitch, roll) of blocks.

This component also manages the block ticking lifecycle, using BitSets to efficiently track blocks that require updates, and a priority queue for ticks scheduled in the future.

### Lifecycle & Ownership
- **Creation:** A BlockSection is instantiated when a new `BlockChunk` is generated by the world generator or when a chunk is loaded from persistent storage via its `CODEC`. It is never created directly by game logic. The `ChunkStore` is the owner of this component.
- **Scope:** The lifetime of a BlockSection is strictly tied to its parent `BlockChunk`. It persists in memory as long as the chunk is active and loaded on the server.
- **Destruction:** The object is eligible for garbage collection when its parent `BlockChunk` is unloaded from memory. There is no explicit destruction method.

## Internal State & Concurrency
- **State:** The BlockSection is a highly mutable component. Its internal state, including block data, lighting, and ticking information, is constantly modified by player interactions, physics simulations, and other game systems. It also maintains several caches, most notably a `SoftReference` to a pre-serialized network packet (`cachedChunkPacket`) to reduce serialization overhead for clients.

- **Thread Safety:** This class is **fully thread-safe**, designed for high-performance concurrent access. This is a critical requirement for a server where multiple threads (game loop, networking, AI, world generation) may need to read or write to the same chunk data simultaneously.

    Thread safety is achieved through a `java.util.concurrent.locks.StampedLock`. This is a sophisticated lock that supports optimistic reads, which are significantly faster than traditional read locks. Most read operations, like `get`, first attempt an optimistic read and only fall back to a full, blocking read lock if the data was concurrently modified. Write operations, like `set`, acquire an exclusive write lock, ensuring atomic updates.

    **WARNING:** The performance of the entire world simulation hinges on the correct and efficient use of this locking mechanism. Any system interacting with a BlockSection must not hold locks for extended periods.

## API Surface
The public API provides a controlled interface for interacting with the block data, abstracting away the complexities of the palette system and concurrency management.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| get(index) | int | O(1) | Retrieves the block ID at a given packed index. Uses an optimistic read lock. |
| set(index, blockId, rotation, filler) | boolean | O(1) | Atomically sets the block, rotation, and filler data. Acquires a write lock. Handles palette promotion/demotion automatically. Returns true if a change occurred. |
| setTicking(index, ticking) | boolean | O(1) | Marks a block as needing a game tick update. Thread-safe. |
| preTick(gameTime) | void | O(N) | Prepares the ticking block set for the current game tick. N is the number of scheduled ticks. |
| forEachTicking(...) | int | O(N) | Executes a provided function for each block that is due for a tick. N is the number of ticking blocks. |
| serializeForPacket(buf) | void | O(N) | Serializes the section's state into a ByteBuf for network transmission. N is the number of blocks. |
| getCachedChunkPacket(x, y, z) | CompletableFuture | O(1) | Asynchronously retrieves a cached, pre-serialized network packet for this section. If the cache is stale, it generates a new one. |

## Integration Patterns

### Standard Usage
Interaction with a BlockSection should always be mediated by its parent `Chunk` or `ChunkStore`. A system should acquire the component, perform its operation, and release its reference.

```java
// Example: A game system placing a block
BlockChunk targetChunk = world.getChunkAt(chunkPos);
if (targetChunk != null) {
    BlockSection section = targetChunk.getSection(sectionY);
    
    // The set method is atomic and handles all internal complexity
    boolean changed = section.set(x, y, z, newBlockId, rotation, filler);

    if (changed) {
        // Notify other systems if a change was made
        world.getLightEngine().onBlockChanged(globalX, globalY, globalZ);
    }
}
```

### Anti-Patterns (Do NOT do this)
- **Direct Instantiation:** Never use `new BlockSection()`. The chunk loading and generation systems are solely responsible for its creation and lifecycle. Direct instantiation will result in a disconnected and non-functional object.
- **Long-Held Locks:** Do not retrieve the internal `chunkSectionLock` and hold it across complex or long-running operations. This will cause severe thread contention and server performance degradation. All interactions should be through the provided atomic methods like `set` and `get`.
- **Direct Palette Modification:** Do not attempt to get and modify the internal `ISectionPalette` objects. The `set` method contains critical logic for promoting a palette to a larger bit size or demoting it to save memory. Bypassing this will lead to data corruption.

## Data Pipeline
The BlockSection is a central hub for block data, with distinct pipelines for persistence, networking, and game logic.

> **Persistence (Saving to Disk):**
> BlockSection State -> `serialize()` -> `CODEC` -> `byte[]` -> ChunkStore -> Disk

> **Networking (Sending to Client):**
> BlockSection State -> `serializeForPacket()` -> `SetChunk` Packet -> `CachedPacket` -> Network Layer -> Client

> **Block Update (Game Logic):**
> Player Input/Game Event -> `set()` -> State Change -> `invalidate()` called -> Lighting Engine & other systems notified -> `getCachedChunkPacket()` is regenerated on next request.


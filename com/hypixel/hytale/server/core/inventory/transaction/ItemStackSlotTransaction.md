---
description: Architectural reference for ItemStackSlotTransaction
---

# ItemStackSlotTransaction

**Package:** com.hypixel.hytale.server.core.inventory.transaction
**Type:** Transient

## Definition
```java
// Signature
public class ItemStackSlotTransaction extends SlotTransaction {
```

## Architecture & Concepts

The ItemStackSlotTransaction is an immutable data record that represents the precise outcome of a single, atomic operation on an inventory slot. It functions as a "receipt" generated by the inventory system, detailing the state change that occurred. It extends the more generic SlotTransaction with context specific to operations involving item stacks, such as the initial query and any resulting remainder.

Architecturally, this class is a critical component of the server's transactional inventory model. Instead of directly mutating inventory state and returning a simple boolean, inventory manipulation methods return an instance of ItemStackSlotTransaction. This provides the calling system with a complete, unambiguous record of the event, including the state before, the state after, the items consumed, and any items that could not be placed.

Its most significant feature is the ability to translate slot indices between nested or composite containers via the `toParent` and `fromParent` methods. This allows a complex inventory, such as a player's screen combining their backpack and a crafting grid, to be treated as a single surface while individual transactions can be correctly mapped to their sub-container origins.

## Lifecycle & Ownership

-   **Creation:** Instances are created exclusively by core inventory systems, such as an ItemContainer, during an item manipulation attempt (e.g., `addItem`, `takeItem`). They are never instantiated directly by gameplay logic. This object is the *result* of an operation, not the input.
-   **Scope:** Extremely short-lived (ephemeral). An instance typically exists only for the duration of the method call that initiated the inventory operation. The caller inspects the transaction result and then discards its reference.
-   **Destruction:** The object is managed by the Java Garbage Collector and is eligible for cleanup as soon as the calling code's scope is exited. It holds no persistent resources.

## Internal State & Concurrency

-   **State:** **Immutable**. All fields are set once in the constructor and cannot be changed. This design guarantees that a transaction result is a stable, reliable record of a past event.
-   **Thread Safety:** **Inherently thread-safe**. Due to its immutability, an ItemStackSlotTransaction instance can be safely passed between threads without any risk of data corruption.
    **WARNING:** While this object is thread-safe, the inventory systems that generate it are almost certainly not. All inventory modifications must be synchronized externally, typically by locking on the root container or processing them on a single game-tick thread.

## API Surface

The public API is designed for inspecting the outcome of an inventory operation.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| succeeded() | boolean | O(1) | (Inherited) Returns true if the transaction was successful. |
| getSlotBefore() | ItemStack | O(1) | (Inherited) The state of the slot before the operation. |
| getSlotAfter() | ItemStack | O(1) | (Inherited) The state of the slot after the operation. |
| getQuery() | ItemStack | O(1) | The item stack that was requested to be added or moved. |
| getRemainder() | ItemStack | O(1) | The portion of the query ItemStack that could not be placed. Null if the entire query was placed. |
| toParent(...) | ItemStackSlotTransaction | O(1) | Creates a new transaction with its slot index translated to a parent container's coordinate space. |
| fromParent(...) | ItemStackSlotTransaction | O(1) | Creates a new transaction with its slot index translated from a parent to a local container's coordinate space. Returns null if the slot is out of bounds. |

## Integration Patterns

### Standard Usage

The standard pattern is to perform an inventory operation and immediately inspect the resulting transaction object to determine the next course of action, such as updating the client or dropping items on the ground.

```java
// Hypothetical usage within a gameplay system
ItemContainer playerInventory = player.getInventory();
ItemStack itemsToAdd = new ItemStack(ItemTypes.STONE, 20);

// The inventory system performs the logic and returns a receipt
ItemStackSlotTransaction result = playerInventory.addItem(itemsToAdd);

if (result.succeeded()) {
    // The operation was fully or partially successful
    if (result.getRemainder() != null) {
        // Not all items could be added, drop the remainder
        world.dropItem(player.getPosition(), result.getRemainder());
    }
    // Always synchronize the client with the final state
    player.getNetworkConnection().send(new PacketUpdateSlot(result.getSlot(), result.getSlotAfter()));
} else {
    // The operation failed completely, no change was made.
}
```

### Anti-Patterns (Do NOT do this)

-   **Direct Instantiation:** Never create an instance using `new ItemStackSlotTransaction()`. Doing so creates a synthetic, invalid record that does not reflect any actual change in an inventory. These objects must only be received from authoritative inventory system calls.
-   **Ignoring the Remainder:** Failing to check `getRemainder()` can lead to item loss. If an operation is partially successful, the remainder represents the items that were not placed and must be handled by the calling logic.
-   **Assuming Success:** Never assume an inventory operation succeeded without checking the `succeeded()` flag. Inventories can be full or have placement restrictions, causing operations to fail.

## Data Pipeline

This class acts as a structured data output from the inventory system. It does not process data itself but rather encapsulates the results of processing done by a container.

> Flow:
> Gameplay Logic Call (e.g., `container.addItem(stack)`) -> Internal Container Logic -> **new ItemStackSlotTransaction(...)** -> Return to Caller -> Caller Inspects Result -> Network Packet Generation / Further Gameplay Logic


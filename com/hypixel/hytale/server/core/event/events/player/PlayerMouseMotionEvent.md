---
description: Architectural reference for PlayerMouseMotionEvent
---

# PlayerMouseMotionEvent

**Package:** com.hypixel.hytale.server.core.event.events.player
**Type:** Transient

## Definition
```java
// Signature
public class PlayerMouseMotionEvent extends PlayerEvent<Void> implements ICancellable {
```

## Architecture & Concepts
The PlayerMouseMotionEvent is a server-side event object that represents a player's mouse movement input. It acts as a high-level, contextualized data structure that translates a raw network packet into a meaningful game event.

This class is a cornerstone of the server's input processing pipeline. Instead of passing low-level protocol objects directly into game logic, the network layer constructs a PlayerMouseMotionEvent. This object is enriched with critical game-state information at the moment of creation, such as the specific block or entity the player is targeting, and the item they are holding.

By encapsulating this snapshot of player intent and world state, the event enables a decoupled, observer-based architecture. Various game systems can listen for this event to implement features like aiming, block interaction previews, or entity highlighting without needing direct knowledge of the networking layer.

## Lifecycle & Ownership
- **Creation:** Instantiated by the server's network packet handler upon receiving a MouseMotionEvent packet from a game client. The constructor is responsible for performing the necessary world queries (raycasting) to determine the target block and entity.
- **Scope:** Extremely short-lived. An instance of this class exists only for the duration of its dispatch through the server's main event bus, which typically occurs within a single server tick.
- **Destruction:** The object is eligible for garbage collection immediately after the event dispatch completes. There are no long-term references held to it.

## Internal State & Concurrency
- **State:** The object's state is a snapshot of the game world at the time of its creation. While its fields are not declared final, they are intended to be immutable. The single exception is the mutable `cancelled` flag, which is fundamental to the ICancellable event pattern.
- **Thread Safety:** This class is **not thread-safe**. Event objects in Hytale are designed to be created and processed on the main server thread. Accessing or modifying an instance from a worker thread will lead to race conditions and severe state corruption. All listener logic must be executed synchronously within the event callback.

## API Surface
The public contract is designed for read-only access to the event's context, with the sole exception of the cancellation mechanism.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| setCancelled(boolean) | void | O(1) | Sets the cancellation state. If set to true, subsequent listeners and default game logic should ignore this event. |
| isCancelled() | boolean | O(1) | Returns true if the event has been cancelled. |
| getClientUseTime() | long | O(1) | Retrieves the client-side timestamp associated with the input. |
| getItemInHand() | Item | O(1) | Returns a reference to the item configuration the player was holding. |
| getTargetBlock() | Vector3i | O(1) | Returns the world coordinates of the block the player was aiming at. May be null. |
| getTargetEntity() | Entity | O(1) | Returns a reference to the entity the player was aiming at. May be null. |
| getScreenPoint() | Vector2f | O(1) | Returns the 2D screen-space coordinates of the mouse cursor. |
| getMouseMotion() | MouseMotionEvent | O(1) | Returns the raw, underlying protocol object from which this event was generated. |

## Integration Patterns

### Standard Usage
The intended use is to subscribe to this event via the server's event bus. Listeners inspect the event's data to implement game logic and can cancel it to prevent default behaviors.

```java
// Example of a system listening for the event
@Subscribe
public void onPlayerMouseMotion(PlayerMouseMotionEvent event) {
    // Prevent interaction if the player is aiming at a protected entity
    Entity target = event.getTargetEntity();
    if (target != null && target.hasComponent(ProtectedComponent.class)) {
        event.setCancelled(true);
        return;
    }

    // Otherwise, update some UI element based on the target
    updateAimingReticule(event.getTargetBlock());
}
```

### Anti-Patterns (Do NOT do this)
- **Direct Instantiation:** Never create an instance using `new PlayerMouseMotionEvent()`. These events must be generated by the server's core input loop to ensure they represent valid, timely client input and contain an accurate world state snapshot.
- **Asynchronous Processing:** Do not store a reference to the event object for processing in a later tick or on a separate thread. The contained data, especially `targetEntity`, may become invalid as the game state changes. The event's context is only guaranteed to be valid for the synchronous duration of its dispatch.
- **State Mutation:** Do not modify any fields on the event object other than through the `setCancelled` method. Modifying the target block or entity reference would violate the "snapshot in time" contract and cause unpredictable behavior in other listeners.

## Data Pipeline
The flow of data from client input to game logic is strictly defined, with this event serving as a key translation step.

> Flow:
> Client Mouse Input -> Network Packet (MouseMotionEvent) -> Server Network Handler -> **PlayerMouseMotionEvent Instantiation** -> Server Event Bus -> Synchronous Event Listeners -> Game Logic Execution


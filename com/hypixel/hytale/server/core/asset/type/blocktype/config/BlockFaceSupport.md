---
description: Architectural reference for BlockFaceSupport
---

# BlockFaceSupport

**Package:** com.hypixel.hytale.server.core.asset.type.blocktype.config
**Type:** Data Object / Configuration Model

## Definition
```java
// Signature
public class BlockFaceSupport implements NetworkSerializable<com.hypixel.hytale.protocol.BlockFaceSupport> {
```

## Architecture & Concepts
BlockFaceSupport is a fundamental data structure that defines the physical support properties of a single face of a block. It is not a service or manager, but rather a plain data object that models a piece of a block's configuration.

This class acts as a critical component in the block asset definition system. During server initialization, block configuration files are deserialized into various objects, with BlockFaceSupport representing the "support" characteristics. Its primary role is to model how blocks connect and physically support each other, forming the basis for placement rules in the game world.

The system operates on two key properties:
1.  **faceType:** A string identifier, such as "Full", that acts as a categorical key. A block requiring "Full" support can be placed on a face that provides a "Full" faceType. This allows for abstract rule-based interaction.
2.  **filler:** An optional array of Vector3i coordinates. This provides a more granular, voxel-level definition of which parts of a block face provide support. If null, the entire face is assumed to provide support.

Crucially, the class implements NetworkSerializable. This signifies that this server-side configuration data is packaged and transmitted to the client, ensuring that client-side prediction and server-side authority operate on identical rule sets.

## Lifecycle & Ownership
-   **Creation:** Instances are almost exclusively created by the Hytale **Codec** system during the server's asset loading phase. The static CODEC field is used to deserialize block definition files from disk into in-memory BlockFaceSupport objects. Programmatic creation can also occur via the static `rotate` method during block placement calculations.
-   **Scope:** The lifecycle of a base BlockFaceSupport object is tied to the BlockType asset it belongs to. These objects are loaded once at server startup and persist in the asset registry for the entire server session. Ephemeral instances, such as those generated by the `rotate` method, are short-lived and exist only for the duration of a specific calculation.
-   **Destruction:** Instances are reclaimed by the garbage collector. Asset-bound instances are cleaned up when the server shuts down and the asset registry is cleared. Ephemeral instances are reclaimed once they fall out of scope.

## Internal State & Concurrency
-   **State:** Mutable. The internal fields `faceType` and `filler` are not final. However, the prevailing architectural pattern is to treat instances loaded from assets as **de-facto immutable**. The primary mutation occurs only once during initial deserialization. The static `rotate` method reinforces this pattern by returning a *new* instance rather than modifying the original.

-   **Thread Safety:** **This class is not thread-safe.** Direct, concurrent modification of its fields will lead to race conditions and unpredictable behavior.

    **Warning:** Access to BlockFaceSupport instances must be externally synchronized if they are to be modified across threads. The standard and expected usage pattern, however, is to treat them as read-only configuration data after the initial asset-loading phase. This makes them safe for concurrent *reads* from multiple game logic threads (e.g., physics, world generation, block updates).

## API Surface
The public API is focused on data retrieval and transformation for use in game logic.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| providesSupportFromFiller(Vector3i) | boolean | O(N) | Checks if a specific sub-voxel coordinate is part of the filler array. N is the size of the filler. |
| rotate(original, yaw, pitch, roll) | BlockFaceSupport | O(N) | **Static factory.** Creates a new, rotated BlockFaceSupport instance. Critical for block orientation logic. |
| toPacket() | protocol.BlockFaceSupport | O(N) | Serializes the object into its network-ready protocol buffer representation for client transmission. |
| getFaceType() | String | O(1) | Returns the categorical support type identifier. |
| getFiller() | Vector3i[] | O(1) | Returns the array of supporting sub-voxel coordinates. May be null. |

## Integration Patterns

### Standard Usage
Developers should not instantiate this class directly in game logic. Instead, they should retrieve it from a loaded BlockType asset to perform placement or physics checks.

```java
// Assume 'world' is the game world and 'blockType' is a loaded asset
BlockFaceSupport supportConfig = blockType.getFaceSupport(BlockFace.TOP);

// Check if this face can support a block requiring "Full" support
if (supportConfig.getFaceType().equals(BlockFaceSupport.FULL_SUPPORTING_FACE)) {
    // Proceed with block placement logic...
}
```

### Anti-Patterns (Do NOT do this)
-   **State Mutation:** Never modify a BlockFaceSupport object retrieved from the central asset registry. This constitutes a global state change and will affect all blocks of that type across the entire server, leading to unpredictable and difficult-to-debug behavior. If a rotated or modified version is needed, create a new instance.
-   **Direct Instantiation:** Avoid `new BlockFaceSupport()` in standard game logic. All block support rules should be defined in asset files to ensure data-driven design and maintain consistency. Direct instantiation should be reserved for unit testing or highly specialized procedural generation systems.

## Data Pipeline
BlockFaceSupport is a critical link in the asset configuration pipeline, flowing from disk to the network.

> Flow:
> Block Asset File (JSON) -> Hytale Codec Deserializer -> **BlockFaceSupport Instance** (In-Memory Asset Registry) -> Game Logic (Physics/Placement) -> `toPacket()` -> Network Serialization Layer -> Client Game State


---
description: Architectural reference for BlockMountPoint
---

# BlockMountPoint

**Package:** com.hypixel.hytale.server.core.asset.type.blocktype.config.mountpoints
**Type:** Transient Data Object

## Definition
```java
// Signature
public class BlockMountPoint {
```

## Architecture & Concepts
BlockMountPoint is a fundamental data structure that defines a logical attachment or "mount" point on a block. It serves as a descriptor, loaded from block asset configuration files, that specifies a precise 3D offset and yaw rotation relative to a block's center.

Architecturally, this class decouples the static definition of a block asset from the dynamic, in-world calculations required by the game simulation. Instead of hard-coding entity positions for objects like chairs or turrets, designers define them declaratively in asset files. The game engine then uses BlockMountPoint instances at runtime to compute the correct world-space position and orientation for any entity that needs to be attached to a block, correctly accounting for the block's own rotation.

The static **CODEC** field is the most critical architectural element, integrating this class directly into the engine's asset serialization pipeline. This ensures that mount point data is loaded, parsed, and validated alongside all other block properties during the server's bootstrap phase.

## Lifecycle & Ownership
-   **Creation:** Primary instances are created by the Hytale asset loading system during server startup. The system uses the static **CODEC** to deserialize JSON definitions into BlockMountPoint objects. Secondary, ephemeral instances are created programmatically by the **rotate** method during gameplay calculations.

-   **Scope:** An instance loaded from an asset file persists for the entire server session, as it is owned by its parent BlockType definition in the central asset registry. Instances generated by the **rotate** method are short-lived and should be considered temporary values for a single calculation, to be discarded immediately after use.

-   **Destruction:** Instances are managed by the Java Garbage Collector. They are destroyed when their parent BlockType is unloaded or when temporary instances go out of scope.

## Internal State & Concurrency
-   **State:** The object's state is **mutable**. It contains a Vector3f for the offset and a float for the yaw offset. While these can be changed after construction, instances managed by the asset system should be treated as immutable. The **rotate** method correctly promotes this pattern by returning a new, transformed instance rather than modifying the original.

-   **Thread Safety:** This class is **not thread-safe**. Its fields are accessed directly with no synchronization primitives.

    **WARNING:** Accessing and especially modifying a BlockMountPoint instance from multiple threads will lead to race conditions and unpredictable behavior. Instances retrieved from the global BlockType registry must be treated as **read-only**. For any transformation, always generate a new instance using the **rotate** method.

## API Surface
The public API is focused on transformation and world-space calculation. Getters are omitted for brevity.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| rotate(yaw, pitch, roll) | BlockMountPoint | O(1) | Creates a new BlockMountPoint by applying block rotations to the offset. This is the primary method for adapting a template mount point to a specific, in-world block instance. |
| computeWorldSpacePosition(blockLoc) | Vector3f | O(1) | Calculates the absolute world-space coordinate of the mount point based on a block's integer location. Does not account for block rotation on its own; use a rotated instance first. |
| computeRotationEuler(rotationIndex) | Vector3f | O(1) | Calculates the final world-space Euler rotation (in radians) for a mounted entity, combining the block's rotation with the mount point's specific yaw offset. |

## Integration Patterns

### Standard Usage
The correct pattern involves retrieving a base mount point from a block's type definition, creating a new rotated instance based on the specific block's orientation, and then using that temporary instance to compute final world coordinates.

```java
// Assume 'block' is an in-world block instance with a known location and rotation
BlockType blockType = block.getType();
BlockMountPoint baseMountPoint = blockType.getMountPoint(0); // Get the template mount point

// Get the block's specific rotation from its rotation index
RotationTuple rotation = RotationTuple.get(block.getRotationIndex());

// Create a new, correctly-rotated mount point for this specific block
BlockMountPoint rotatedMountPoint = baseMountPoint.rotate(rotation.yaw(), rotation.pitch(), rotation.roll());

// Compute final world-space coordinates from the new, rotated instance
Vector3f worldPosition = rotatedMountPoint.computeWorldSpacePosition(block.getLocation());
Vector3f worldRotation = rotatedMountPoint.computeRotationEuler(block.getRotationIndex());

// Apply these final coordinates to the entity being mounted
mountedEntity.setPosition(worldPosition);
mountedEntity.setRotation(worldRotation);
```

### Anti-Patterns (Do NOT do this)
-   **Direct Instantiation:** Avoid `new BlockMountPoint()` in game logic. Mount points are configuration data and should be defined in asset files and retrieved via the BlockType. Manual creation is reserved for tooling or procedural generation systems.

-   **Mutating Registry Instances:** Never modify a BlockMountPoint instance retrieved from a BlockType. This is not thread-safe and will globally affect all blocks of that type, leading to severe and hard-to-debug visual and physical glitches.

-   **Ignoring Rotation:** Using a base mount point directly from a BlockType without first calling the **rotate** method will result in incorrect entity positioning for any block that is not in its default orientation.

## Data Pipeline
BlockMountPoint acts as a bridge between static asset configuration and the live entity simulation system.

> Flow:
> Block Asset File (JSON) -> Asset Deserializer (using CODEC) -> In-Memory BlockType -> **BlockMountPoint** -> Entity System Calculation -> Final Entity Transform (Position & Rotation)


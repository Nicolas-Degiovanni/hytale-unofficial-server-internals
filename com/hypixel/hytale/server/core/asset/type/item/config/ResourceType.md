---
description: Architectural reference for ResourceType
---

# ResourceType

**Package:** com.hypixel.hytale.server.core.asset.type.item.config
**Type:** Asset Data Model

## Definition
```java
// Signature
public class ResourceType
   implements JsonAssetWithMap<String, DefaultAssetMap<String, ResourceType>>,
   NetworkSerializable<com.hypixel.hytale.protocol.ResourceType> {
```

## Architecture & Concepts

The ResourceType class is a data-driven configuration object, not an active service. It represents a fundamental, definable resource within the game world, such as wood, stone, or ore. These objects are not instantiated procedurally; instead, they are deserialized from on-disk JSON asset files during the engine's startup sequence.

The core of this class's architecture is the static final **CODEC** field. This `AssetBuilderCodec` instance acts as a schema, a deserializer, and a data-mapper. It declaratively defines how JSON properties like "Name", "Description", and "Icon" are mapped to the corresponding Java fields of a ResourceType instance. This codec-driven approach centralizes the loading logic, supports asset inheritance (where one JSON file can extend another), and integrates validation, such as ensuring the "Icon" field points to a valid texture resource.

Functionally, ResourceType serves as a bridge between three critical domains:
1.  **Configuration:** The canonical definition stored in JSON files.
2.  **Game State:** The in-memory Java object, accessible globally via the AssetStore.
3.  **Network Protocol:** The network-optimized representation generated by the toPacket method for client-server synchronization.

Instances of ResourceType are managed by a global, lazily-initialized **AssetStore**, which is retrieved from the central AssetRegistry. This ensures that all game systems access the same canonical set of resource definitions.

## Lifecycle & Ownership

-   **Creation:** ResourceType instances are created exclusively by the Hytale asset loading system during server or client bootstrap. The static CODEC is invoked by the AssetStore to parse and deserialize corresponding JSON files into memory. Manual instantiation is an anti-pattern and will result in an unmanaged object that is invisible to the rest of the engine.
-   **Scope:** Application-scoped. Once an asset is loaded into the AssetStore, it persists for the entire lifetime of the application session. The data within is treated as immutable configuration.
-   **Destruction:** Objects are garbage collected along with the entire AssetStore when the JVM shuts down. There is no explicit cleanup or de-allocation mechanism.

## Internal State & Concurrency

-   **State:** The object's state (id, name, description, icon) is effectively immutable post-initialization. While the fields are not marked as final, they are set only once during the deserialization process. The single piece of mutable state is the `cachedPacket` SoftReference, which is a performance optimization for network serialization.
-   **Thread Safety:** The class is conditionally thread-safe.
    -   **Read Operations:** After the initial asset loading phase is complete, reading data from a ResourceType instance (e.g., calling getName) is safe from any thread.
    -   **Initialization:** The static `getAssetStore` method contains a potential race condition if called by multiple threads before the ASSET_STORE field is initialized. In practice, this is a non-issue as asset loading is typically a single-threaded, blocking operation during startup.
    -   **toPacket Method:** The `toPacket` method's cache mutation is not protected by a lock. Concurrent calls on the same instance could result in the creation of multiple packet objects, but this is a benign race condition. The performance impact is negligible, and the final state will be consistent.

## API Surface

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| getAssetStore() | static AssetStore | O(1) Amortized | Retrieves the global, singleton-like store for all ResourceType assets. |
| getAssetMap() | static DefaultAssetMap | O(1) Amortized | Convenience method to directly access the underlying map of resource IDs to objects. |
| getId() | String | O(1) | Returns the unique identifier for the resource (e.g., "hytale:wood"). |
| getName() | String | O(1) | Returns the human-readable, localized name of the resource. |
| toPacket() | com.hypixel.hytale.protocol.ResourceType | O(1) | Creates a network-optimized DTO. Uses an internal SoftReference cache to avoid repeated allocations. |

## Integration Patterns

### Standard Usage

To access a defined resource, a developer must retrieve it from the global AssetStore using its unique string identifier. Direct instantiation is strictly forbidden.

```java
// Retrieve the central asset store for all ResourceType definitions
AssetStore<String, ResourceType, ?> store = ResourceType.getAssetStore();

// Look up a specific resource by its canonical ID
ResourceType stoneResource = store.get("hytale:stone");

if (stoneResource != null) {
    // Use the immutable data for game logic
    String displayName = stoneResource.getName();
    String networkIcon = stoneResource.getIcon();
} else {
    // Handle cases where the asset definition is missing
    // This typically indicates a configuration error.
}
```

### Anti-Patterns (Do NOT do this)

-   **Direct Instantiation:** Never use `new ResourceType()`. This creates a "phantom" object that is not registered in the AssetStore and will not be recognized by other game systems. All resources must be defined in JSON files.
-   **State Mutation:** Do not attempt to modify the fields of a ResourceType instance via reflection or other means after it has been loaded. These objects are considered immutable configuration data, and changing them at runtime will lead to undefined behavior and state desynchronization.
-   **Pre-Initialization Access:** Do not attempt to call `ResourceType.getAssetStore()` before the main asset loading phase of the engine has completed.

## Data Pipeline

The flow of data for a ResourceType begins as a static file and ends as a synchronized object on the client.

> Flow:
> `stone.json` -> AssetStore Loader -> **ResourceType.CODEC** -> **ResourceType Instance** (in Server Memory) -> Game Logic -> `toPacket()` -> Network Layer -> Client Game State


---
description: Architectural reference for CustomUIHud
---

# CustomUIHud

**Package:** com.hypixel.hytale.server.core.entity.entities.player.hud
**Type:** Transient Base Class

## Definition
```java
// Signature
public abstract class CustomUIHud {
```

## Architecture & Concepts
The CustomUIHud class is an abstract, server-side controller for managing a player's custom user interface elements. It serves as the foundational component for any dynamic, server-driven UI that needs to be displayed to a specific client.

Its primary architectural role is to decouple game logic from the low-level details of UI packet construction. It employs the **Template Method** design pattern, where the `show` method defines a fixed algorithm for building and sending a UI, while delegating the specific UI construction logic to concrete subclasses via the abstract `build` method.

This system uses a command-based approach. The server does not render a UI; instead, it generates a list of declarative commands (e.g., "create label", "set position") using a UICommandBuilder. These commands are serialized into a CustomHud packet and sent to the client, which is responsible for interpreting and rendering the final interface. This minimizes network traffic and keeps the server agnostic of client-side rendering technology.

## Lifecycle & Ownership
- **Creation:** A concrete implementation of CustomUIHud is instantiated by server-side game logic whenever a specific UI needs to be presented to a player. The constructor requires a PlayerRef, permanently binding the HUD instance to a single player's network session.
- **Scope:** The object's lifetime is transient and context-dependent. It exists only for the duration that its corresponding UI is considered active. It is not a session-scoped or global service. For example, a `ShopHud` might be created when a player interacts with a vendor and destroyed when they close the shop window.
- **Destruction:** The object is managed by the Java Garbage Collector. It becomes eligible for collection as soon as all references to it are released. There is no explicit `destroy` or `close` method.

## Internal State & Concurrency
- **State:** The core state is the `playerRef` field, which is immutable and assigned at construction. The class itself is inherently stateful due to this reference. However, it does not cache the generated UI commands; the UI is rebuilt from scratch on each call to `show`. Subclasses may introduce further state, but this is discouraged.
- **Thread Safety:** This class is **not thread-safe** and must not be accessed from multiple threads. All interactions, particularly calls to `show` and `update`, must be synchronized with the server's main game loop or the specific thread responsible for processing the associated player's updates. Unsynchronized access will lead to packet corruption and severe client-side rendering errors.

## API Surface
| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| show() | void | O(N) | High-level entry point. Orchestrates the UI build and network send process. N is the number of UI commands generated by the `build` method. |
| update(boolean, UICommandBuilder) | void | O(M) | Low-level method to send a pre-built set of UI commands to the client. M is the number of commands in the provided builder. |
| getPlayerRef() | PlayerRef | O(1) | Returns the player entity this HUD is bound to. |
| build(UICommandBuilder) | protected abstract void | O(N) | The core template method. Subclasses must implement this to define the UI layout by populating the builder. |

## Integration Patterns

### Standard Usage
The intended pattern is to extend CustomUIHud, implement the `build` logic, and then instantiate and `show` the subclass in response to a game event.

```java
// 1. Define a concrete HUD implementation
public class WelcomeMessageHud extends CustomUIHud {
    private final String message;

    public WelcomeMessageHud(PlayerRef playerRef, String message) {
        super(playerRef);
        this.message = message;
    }

    @Override
    protected void build(UICommandBuilder builder) {
        // This logic defines the actual UI components
        builder.beginPanel("welcome_panel");
        builder.addLabel(this.message);
        builder.endPanel();
    }
}

// 2. Instantiate and display the HUD for a player
PlayerRef targetPlayer = ...;
WelcomeMessageHud welcomeHud = new WelcomeMessageHud(targetPlayer, "Welcome to the server!");
welcomeHud.show(); // Builds and sends the UI to the player
```

### Anti-Patterns (Do NOT do this)
- **Calling from an Unsafe Thread:** Never call `show` or `update` from an asynchronous callback or a worker thread without first dispatching the call to the player's main update thread.
- **Storing Mutable UI State:** Subclasses should avoid storing complex, mutable state related to the UI. The `build` method should be able to reconstruct the UI's appearance from authoritative game state (e.g., player inventory, quest status) at any time.
- **Reusing UICommandBuilder:** Do not cache or reuse a UICommandBuilder instance across multiple `update` calls. The `show` method correctly creates a new builder for each operation to ensure a clean state.

## Data Pipeline
The flow of data originates from server logic and terminates at the client's rendering engine. This class is a critical link in that chain.

> Flow:
> Server Game Event -> `new ConcreteHud(playerRef)` -> `hud.show()` -> `build()` populates UICommandBuilder -> `update()` creates `CustomHud` Packet -> Player's PacketHandler -> Network Layer -> Client Network Receiver -> Client UI System -> Render to Screen


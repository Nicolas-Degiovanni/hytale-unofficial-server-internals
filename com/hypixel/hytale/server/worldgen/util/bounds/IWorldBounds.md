---
description: Architectural reference for IWorldBounds
---

# IWorldBounds

**Package:** com.hypixel.hytale.server.worldgen.util.bounds
**Type:** Contract Interface

## Definition
```java
// Signature
public interface IWorldBounds extends IChunkBounds {
```

## Architecture & Concepts
The IWorldBounds interface is a fundamental contract within the server-side world generation system. It defines a three-dimensional, axis-aligned volume in world space. By extending the two-dimensional IChunkBounds, it inherits the concept of a horizontal area and adds vertical constraints via the Y-axis.

This interface serves as a critical abstraction, decoupling world generation algorithms from the specific shape or size of the region they operate in. Systems like biome placers, structure generators, and ore vein distributors receive an implementation of IWorldBounds to understand their operational limits. This ensures that procedural generation tasks do not bleed into adjacent regions or exceed the designated vertical space, preventing world corruption and ensuring predictable outcomes.

It represents a *spatial contract* rather than a concrete object. Any system that needs to define a 3D operational area for world generation must use or provide an object that implements this interface.

## Lifecycle & Ownership
As an interface, IWorldBounds itself has no lifecycle. The lifecycle described here pertains to the concrete objects that implement this contract.

- **Creation:** Instances are typically created by high-level world generation coordinators or biome managers. For example, when a specific biome is being generated, a `BiomeBounds` object implementing IWorldBounds is instantiated to define the biome's volume.
- **Scope:** The lifetime of an IWorldBounds implementation is tied to the scope of the generation task it constrains. It may be short-lived, existing only for the placement of a single feature, or it may persist for the entire generation of a world region.
- **Destruction:** Instances are managed by the Java Garbage Collector. They are eligible for collection once the world generation task that created them is complete and all references are released.

## Internal State & Concurrency
The interface contract implies that implementations should be treated as immutable or, at a minimum, thread-safe for read operations. World generation is a highly concurrent process, and multiple worker threads may query the same bounds object simultaneously to determine placement validity.

- **State:** The interface itself is stateless. Implementations are expected to hold state defining the minimum and maximum X, Y, and Z coordinates.
- **Thread Safety:** Implementations **must be thread-safe**. It is a severe design violation to create a mutable IWorldBounds implementation that is shared across threads without explicit synchronization. The expected pattern is "write-once, read-many," where the bounds are defined and then passed to worker threads as a read-only constraint.

## API Surface
The public contract focuses on querying the vertical limits and providing utility functions for vertical placement.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| getLowBoundY() | int | O(1) | Returns the minimum inclusive Y-coordinate of the volume. |
| getHighBoundY() | int | O(1) | Returns the maximum exclusive Y-coordinate of the volume. |
| intersectsChunk(long) | boolean | O(1) | Default method. Checks if the 2D projection of the bounds intersects a chunk. |
| randomY(Random) | int | O(1) | Default method. Returns a random Y-coordinate within the vertical bounds. |
| fractionY(double) | double | O(1) | Default method. Calculates a Y-coordinate at a fractional height within the bounds. |

## Integration Patterns

### Standard Usage
A world generation algorithm receives an IWorldBounds instance from a higher-level system to constrain its work. It uses the interface to validate coordinates before placing blocks or entities.

```java
// A feature generator receives bounds from the world generator
public void generateFeature(IWorldBounds bounds, Random random) {
    // Find a starting Y-level within the allowed vertical space
    int startY = bounds.randomY(random);

    // ... logic to generate the feature at startY ...
    // The generator must ensure all its blocks stay within the full 3D bounds.
}
```

### Anti-Patterns (Do NOT do this)
- **Contract Violation:** Implementing the interface where `getLowBoundY()` returns a value greater than `getHighBoundY()` is a critical error. This will cause undefined behavior, including infinite loops or crashes in algorithms that rely on a valid range.
- **Ignoring the Bounds:** A generator that receives an IWorldBounds object but proceeds to place blocks outside its defined volume is a severe bug. This can lead to world corruption, as it overwrites data being generated by a concurrent task in an adjacent region.
- **Mutable Implementations:** Sharing a mutable implementation of IWorldBounds across multiple generation threads without proper locking will lead to race conditions and non-deterministic world generation. Bounds should be treated as immutable after creation.

## Data Pipeline
IWorldBounds acts as a data-driven constraint within the world generation pipeline. It does not process data itself but rather guides the flow and placement of generated world data.

> Flow:
> Biome Placement Engine -> Defines region -> Creates **IWorldBounds implementation** -> Passes to Feature Generator -> Generator queries bounds -> Produces Block Data for World Chunks


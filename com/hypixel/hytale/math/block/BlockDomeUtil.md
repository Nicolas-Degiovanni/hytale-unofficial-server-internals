---
description: Architectural reference for BlockDomeUtil
---

# BlockDomeUtil

**Package:** com.hypixel.hytale.math.block
**Type:** Utility

## Definition
```java
// Signature
public class BlockDomeUtil {
```

## Architecture & Concepts
The BlockDomeUtil class is a stateless, static utility that provides high-performance algorithms for rasterizing ellipsoid and dome shapes within the game's block grid. It serves as a foundational component for procedural world generation, structure placement, and potentially in-game tools that create large-scale geometric forms.

The core architectural purpose of this class is to translate a continuous mathematical definition of an ellipsoid into a discrete set of integer block coordinates. It achieves this by iterating through a bounding box and testing each point against the standard ellipsoid equation: `(x/a)^2 + (y/b)^2 + (z/c)^2 <= 1`.

To improve the visual quality and reduce aliasing, the radii are internally expanded by a small constant (0.41F). This technique ensures that blocks near the true mathematical surface are included, resulting in a fuller, more natural-looking shape.

A key optimization is the use of symmetry. The internal `test` method calculates coordinates for a single octant of the dome and then mirrors these coordinates across the X and Z axes. This reduces the number of expensive square root and multiplication operations by a factor of four for each horizontal slice.

## Lifecycle & Ownership
- **Creation:** This class is never instantiated. As a utility class containing only static methods, its functionality is accessed directly via the class name (e.g., BlockDomeUtil.forEachBlock).
- **Scope:** The class and its methods are stateless. Their scope is limited to the duration of a single static method invocation. No data persists between calls.
- **Destruction:** Not applicable. The class is loaded by the JVM and remains available for the lifetime of the application.

## Internal State & Concurrency
- **State:** BlockDomeUtil is **completely stateless and immutable**. It contains no member fields and all computations are based exclusively on the arguments provided to its methods.
- **Thread Safety:** This class is inherently **thread-safe**. Multiple threads can invoke its methods concurrently without any risk of data corruption or race conditions.

    **WARNING:** While the utility itself is thread-safe, the provided `TriIntObjPredicate` consumer is not guaranteed to be. The caller is responsible for ensuring that the consumer logic, especially any operations that modify shared world state, is properly synchronized.

## API Surface
The public API consists of two overloaded methods for generating solid or hollow domes.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| forEachBlock(origin, radii, context, consumer) | boolean | O(Rx * Ry * Rz) | Iterates over every block position within a solid ellipsoid. Short-circuits and returns false if the consumer returns false. |
| forEachBlock(origin, radii, thickness, capped, context, consumer) | boolean | O(Rx * Ry * Rz) | Iterates over block positions forming a hollow ellipsoid shell of a given thickness. Short-circuits if the consumer returns false. |

## Integration Patterns

### Standard Usage
This utility is designed to be called by higher-level systems like world generators or structure processors. The standard pattern is to provide a lambda or method reference that performs an action, such as placing a block, for each coordinate generated by the iterator.

```java
// Example: Creating a solid stone dome in the world
World world = context.getWorld();
int originX = 100, originY = 64, originZ = 200;
int radiusX = 15, radiusY = 10, radiusZ = 15;

// The consumer predicate places a block and always returns true to continue iteration.
BlockDomeUtil.forEachBlock(
    originX, originY, originZ,
    radiusX, radiusY, radiusZ,
    world, // The context object passed to the consumer
    (x, y, z, w) -> {
        w.setBlock(x, y, z, Block.STONE);
        return true;
    }
);
```

### Anti-Patterns (Do NOT do this)
- **Excessive Radii:** Invoking `forEachBlock` with extremely large radii within a single game tick can cause significant performance degradation and server lag. For very large structures, consider distributing the work over multiple ticks.
- **Complex Consumer Logic:** The consumer predicate is executed for every single block in the shape. Performing computationally expensive or blocking operations within the consumer will directly impact the performance of the entire iteration.
- **Ignoring Return Value:** The boolean return value indicates whether the iteration completed or was short-circuited. Ignoring this can lead to bugs if subsequent logic depends on the successful completion of the entire shape.

## Data Pipeline
BlockDomeUtil acts as a coordinate generator. It does not manage data persistence or transformation itself; it simply produces a stream of coordinates that are fed into a consumer.

> Flow:
> World Generator -> **BlockDomeUtil.forEachBlock**(params) -> (x, y, z) Coordinate Stream -> Consumer Predicate -> World State Mutation


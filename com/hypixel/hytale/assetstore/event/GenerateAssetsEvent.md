---
description: Architectural reference for GenerateAssetsEvent
---

# GenerateAssetsEvent

**Package:** com.hypixel.hytale.assetstore.event
**Type:** Transient

## Definition
```java
// Signature
public class GenerateAssetsEvent<K, T extends JsonAssetWithMap<K, M>, M extends AssetMap<K, T>> extends AssetsEvent<K, T> implements IProcessedEvent {
```

## Architecture & Concepts
The GenerateAssetsEvent is a specialized, stateful event that serves as the primary mechanism for procedural or mod-driven asset creation at runtime. It functions as a transactional context, allowing multiple systems to safely and concurrently add new assets into the game's central AssetRegistry.

This event is dispatched by an AssetStore after it has completed its initial loading phase from disk. It provides a critical hook for systems that need to define assets that are not declared in static files, such as procedurally generated items, blocks, or entities based on world-generation seeds or other dynamic factors.

Listeners subscribe to this event and use its API to register new assets. The event object collects all these additions into temporary, thread-safe collections. Crucially, it implements the IProcessedEvent interface. This signals to the event bus that after all listeners have completed their work, the bus must invoke the event's own processEvent method. This method acts as the "commit" phase of the transaction, merging all the newly generated assets into the live AssetStore collections in a single, controlled operation. This two-phase (collect-then-commit) pattern ensures atomicity and prevents race conditions during the asset generation process.

### Lifecycle & Ownership
-   **Creation:** Instantiated and dispatched by an AssetStore immediately after its initial asset load is complete. The event is constructed with direct references to the AssetStore's live data collections, providing a snapshot-in-time for listeners to work against.
-   **Scope:** The event's lifecycle is extremely short, confined to the duration of its dispatch on the event bus. It is designed to be used and then immediately discarded.
-   **Destruction:** Once processEvent has been called by the event bus, the event's internal collections are cleared, and it becomes eligible for garbage collection. Holding a reference to this event after its dispatch cycle is complete is a critical error and will lead to memory leaks and unpredictable behavior.

## Internal State & Concurrency
-   **State:** This object is highly mutable. Its primary purpose is to accumulate state from multiple, potentially concurrent, listeners. It holds two categories of state:
    1.  **Initial State:** References to the AssetStore's collections at the time of creation (e.g., loadedAssets, assetChildren). A read-only, unmodifiable view of this state is exposed to listeners.
    2.  **Accumulated State:** A set of temporary collections (addedAssets, addedAssetChildren) that store the new assets being generated by listeners.

-   **Thread Safety:** The class is designed for concurrent access. The internal collections used for accumulating new assets (`ConcurrentHashMap`, `ConcurrentHashMap.newKeySet()`) are thread-safe. This design explicitly supports an event bus that dispatches events to listeners across multiple worker threads, allowing for parallel asset generation. The final `processEvent` method acts as the synchronization barrier, safely merging the results from all threads into the main, non-concurrent asset maps.

## API Surface
The public API is designed as a command interface for registering new assets.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| getLoadedAssets() | Map<K, T> | O(1) | Returns an **unmodifiable** map of assets that were loaded before this event was fired. Used for validation. |
| addChildAsset(childKey, asset, parent) | void | O(log N) | Registers a new asset and establishes a parent-child relationship. Throws IllegalArgumentException if the parent does not exist or if validation fails. |
| addChildAssetWithReference(childKey, asset, parentClass, parentKey) | void | O(log N) | Registers a new asset and links it to a parent of a potentially different asset type. Requires lookups in the global AssetRegistry. |
| processEvent(hookName) | void | O(A) | **Internal Engine Use Only.** Commits all added assets to the AssetStore. Complexity is proportional to the number of added assets (A). |

## Integration Patterns

### Standard Usage
The intended use is within an event listener that subscribes to this specific event type. The listener creates new asset objects and uses the event's API to register them.

```java
// In a mod initialization or procedural generation system
public void onGenerateBlocks(GenerateAssetsEvent<String, Block, BlockMap> event) {
    // Create a new, dynamically defined Block asset
    Block myProceduralBlock = new Block();
    myProceduralBlock.setDisplayName("Procedural Crystal");
    // ... configure other properties

    // Register the new block, linking it to an existing parent
    // This will throw an exception if "hytale:stone" does not exist
    event.addChildAsset("mymod:procedural_crystal", myProceduralBlock, "hytale:stone");
}
```

### Anti-Patterns (Do NOT do this)
-   **Direct Instantiation:** Never call `new GenerateAssetsEvent()`. The event is invalid unless created by an AssetStore with the correct initial state. It must be received from the event bus.
-   **Holding References:** Do not cache the event object in a field or static variable. Its state is cleared after processing, and holding a reference will prevent garbage collection and cause unexpected behavior if reused.
-   **Modifying Live Collections:** Do not attempt to modify the map returned by getLoadedAssets. It is unmodifiable and will throw an UnsupportedOperationException. All additions must go through the provided `addChildAsset` methods.
-   **Calling processEvent Manually:** The processEvent method is part of the IProcessedEvent contract and is invoked automatically by the event bus. Calling it manually will prematurely commit assets and disrupt the event lifecycle.

## Data Pipeline
The event orchestrates a control flow for dynamic asset injection rather than a traditional data transformation pipeline.

> Flow:
> AssetStore Initial Load -> **GenerateAssetsEvent** Creation -> Event Bus Dispatch -> Listeners (Mods, Procedural Systems) -> **GenerateAssetsEvent** State Accumulation -> Event Bus Post-Processing -> **GenerateAssetsEvent.processEvent()** -> AssetStore State Mutation

---


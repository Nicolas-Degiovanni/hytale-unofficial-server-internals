---
description: Architectural reference for FilterQuery
---

# FilterQuery

**Package:** com.hypixel.hytale.builtin.portals.utils.posqueries.predicates.generic
**Type:** Transient

## Definition
```java
// Signature
public class FilterQuery implements SpatialQuery {
```

## Architecture & Concepts
The FilterQuery is a foundational component within the Spatial Query subsystem, implementing the Decorator pattern to augment existing query operations. Its primary function is to apply a conditional test, represented by a PositionPredicate, to a stream of candidate positions generated by a wrapped SpatialQuery.

This class is the primary mechanism for composing complex, multi-stage positional searches. Instead of creating monolithic query classes with hardcoded logic, developers can chain together simple, reusable queries and predicates. For example, a base query might generate all positions within a sphere, which is then passed to a FilterQuery to check for solid ground, and the result is passed to another FilterQuery to ensure sufficient vertical clearance.

The inclusion of a **failFast** mechanism is a critical performance optimization. When enabled, the stream processing is terminated as soon as a single candidate fails the predicate test. This is highly effective in scenarios where the order of candidates is significant and the goal is to find a contiguous block of valid positions.

## Lifecycle & Ownership
- **Creation:** Instantiated directly via its constructor, typically as part of a method-local query-building sequence. It is not a managed service.
- **Scope:** Short-lived and stateless. A FilterQuery instance exists only for the duration of a single, composite query execution. Once the resulting stream is consumed, the FilterQuery object is eligible for garbage collection.
- **Destruction:** Managed entirely by the Java Garbage Collector. There are no manual cleanup or disposal requirements.

## Internal State & Concurrency
- **State:** Immutable. The internal fields for the source query, predicate, and failFast flag are set at construction and never change. The class holds no caches or mutable operational state.
- **Thread Safety:** Conditionally thread-safe. The FilterQuery class itself introduces no concurrency hazards. However, its thread safety is entirely dependent on the thread safety of the wrapped SpatialQuery and PositionPredicate implementations it is constructed with. The internal use of AtomicBoolean for the fail-fast mechanism ensures safe state-checking if the stream were to be processed in parallel, but consumers must guarantee that the underlying world data access and predicate logic are also safe for concurrent execution.

## API Surface

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| createCandidates(World, Vector3d, SpatialQueryDebug) | Stream<Vector3d> | O(N * P) | Returns a new stream of candidate positions. It lazily pulls candidates from the wrapped query and applies the predicate. N is the number of source candidates and P is the complexity of the predicate. |

## Integration Patterns

### Standard Usage
The intended use is to wrap an existing SpatialQuery to add a filtering condition. This promotes a highly composable and readable approach to defining complex location searches.

```java
// 1. Define a source of candidate positions (e.g., all points in a 10-block radius)
SpatialQuery sourceQuery = new SphereQuery(10);

// 2. Define the condition to test (e.g., the block must be of a certain type)
PositionPredicate predicate = (world, pos) -> world.getBlock(pos).isType(BlockType.STONE);

// 3. Compose the source and the predicate using FilterQuery
SpatialQuery stoneSearchQuery = new FilterQuery(sourceQuery, predicate);

// 4. Execute the final query to get a stream of valid stone block positions
Stream<Vector3d> results = stoneSearchQuery.createCandidates(world, origin, null);
```

### Anti-Patterns (Do NOT do this)
- **Stateful Predicates:** Avoid using a PositionPredicate that maintains mutable state across invocations. The stream processing contract does not guarantee execution order, and stateful logic can lead to non-deterministic and incorrect filtering results. Each predicate test must be an independent, idempotent operation.
- **Re-implementing Filtering:** Do not create a custom SpatialQuery that internally generates and then filters candidates. This violates the single responsibility principle. Decompose the logic into a generator query and a separate FilterQuery for maintainability and reusability.

## Data Pipeline
FilterQuery acts as an intermediate processing stage in a stream-based data pipeline. It consumes a stream of positions and produces a new, more refined stream.

> Flow:
> Source SpatialQuery -> Unfiltered Stream<Vector3d> -> **FilterQuery** (Applies PositionPredicate) -> Filtered Stream<Vector3d> -> Terminal Operation (e.g., findFirst, collect)


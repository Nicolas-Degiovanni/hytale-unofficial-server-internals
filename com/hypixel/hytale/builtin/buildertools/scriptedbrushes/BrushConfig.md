---
description: Architectural reference for BrushConfig
---

# BrushConfig

**Package:** com.hypixel.hytale.builtin.buildertools.scriptedbrushes
**Type:** State Object

## Definition
```java
// Signature
public class BrushConfig {
```

## Architecture & Concepts

The BrushConfig class is a mutable state container that defines the complete behavior and context for a single builder tool operation. It is the central authority for a brush's properties, decoupling the brush's *definition* (its shape, material pattern, and filters) from its *execution* (the specific location and type of a player interaction).

This class is not the executor itself, but rather the blueprint and live context that an executor (like a ScriptedBrush) consumes. Its primary architectural role is to serve as a Data Transfer Object between the user interface, scripting engine, and the world modification logic.

A key concept is the dual-masking system. The BrushConfig maintains two distinct masks:
1.  **Brush Mask:** A long-lived filter, typically defining the types of blocks the brush is allowed to replace (e.g., a "paint over grass and dirt only" brush).
2.  **Operation Mask:** A transient, single-use filter, often generated by a script for a specific operation (e.g., "only affect blocks within this temporary selection").

These masks are combined internally into a final `combinedMasks` field, which provides a single, efficient mask for the brush execution logic to check against.

## Lifecycle & Ownership

The lifecycle of a BrushConfig instance is transactional, centered around a single, continuous player interaction (e.g., a single click or a click-and-drag action).

-   **Creation:** An instance is typically created and owned by a higher-level tool or brush controller. It is initialized with default values via the constructor, which calls `resetToDefaultValues`. Configurations can be cloned using the copy constructor, allowing for saving and loading of brush presets.

-   **Scope:** While the object may persist as long as a tool is active, its *execution state* is strictly bounded by the `beginExecution` and `endExecution` calls. This defines a "unit of work" for a single brush stroke. All properties related to a specific world interaction (like `origin` and `interactionType`) are only valid within this scope.

-   **Destruction:** The object is eligible for garbage collection when its owning tool controller is discarded. There is no explicit destruction method. The `endExecution` method serves as a logical reset, returning the object to a default, non-executing state, ready for the next interaction.

## Internal State & Concurrency

-   **State:** BrushConfig is highly mutable by design. Its properties are expected to change frequently in response to user input or script commands. It caches the result of combining the `brushMask` and `operationMask` in the `combinedMasks` field to avoid re-computation on every block check during an operation.

-   **Thread Safety:** **This class is not thread-safe.** It contains no internal locking mechanisms and its state is exposed via public setters. The static `Random` instance is shared across all instances of BrushConfig, which could be a point of contention if builder tools were ever executed concurrently.

    **WARNING:** All interactions with a BrushConfig instance must be confined to a single thread, assumed to be the main server thread responsible for processing player actions. Passing this object between threads will result in unpredictable behavior and state corruption.

## API Surface

The public API is designed for configuration and for querying state during a bounded execution.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| beginExecution(origin, isHoldDown, type) | void | O(1) | Marks the start of a brush stroke. Captures the interaction's origin and type, making the object enter an "executing" state. |
| endExecution() | void | O(1) | Marks the end of a brush stroke. Resets all execution-specific fields and returns the object to its default state. |
| setPattern(pattern) | void | O(1) | Sets the material pattern the brush will use. |
| setShape(shape) | void | O(1) | Sets the geometric shape of the brush (e.g., Cube, Sphere). |
| setShapeWidth(width) | void | O(1) | Sets the primary dimension of the brush shape. |
| setBrushMask(mask) | void | O(1) | Configures the persistent block filter for the brush. |
| setOperationMask(mask) | void | O(1) | Configures the transient block filter for the current operation. |
| getNextMaterial() | Material | O(1) | Returns the next material to place, determined by the current pattern and the shared random number generator. |
| getBlockMask() | BlockMask | O(1) | Returns the final, combined mask to be used for filtering world modifications. |

## Integration Patterns

### Standard Usage

A controlling entity, such as a ScriptedBrush, manages the BrushConfig lifecycle. It configures the instance based on user settings and then uses it to execute a world modification.

```java
// A BrushExecutor would hold and manage the config
BrushConfig config = new BrushConfig();
config.setShape(BrushShape.Sphere);
config.setShapeWidth(10);
config.setPattern(BlockPattern.parse("grass, dirt"));

// On player interaction...
Vector3i interactionPoint = player.getLookAtBlock();
config.beginExecution(interactionPoint, false, InteractionType.PRIMARY);

// The executor would then iterate through the shape's volume
// For each block in volume:
//   if (config.getBlockMask().matches(world.getBlock(pos))) {
//     Material nextMat = config.getNextMaterial();
//     world.setMaterial(pos, nextMat);
//   }

config.endExecution();
```

### Anti-Patterns (Do NOT do this)

-   **State Bleeding:** Do not forget to call `endExecution`. Failure to do so will cause the state from one operation (e.g., its `origin`) to leak into the next, leading to unpredictable brush behavior.

-   **Race Conditions:** Do not access execution-specific properties like `getOrigin()` or `getInteractionType()` when `isCurrentlyExecuting()` is false. These fields are null or contain stale data outside of a `beginExecution`/`endExecution` block.

-   **Shared Instances:** Do not share a single BrushConfig instance between multiple, concurrent operations or players. This will lead to severe state corruption. If a configuration needs to be reused, create a deep copy using the copy constructor: `new BrushConfig(other)`.

## Data Pipeline

The BrushConfig acts as a stateful processor in the builder tools data pipeline. It does not move data itself, but its state directs the flow of the world modification process.

> Flow:
> Player Input (Interaction Packet) -> Tool Controller -> **BrushConfig**.beginExecution -> Brush Executor reads **BrushConfig** state (Shape, Origin, Pattern, Mask) -> World Modification API -> **BrushConfig**.endExecution


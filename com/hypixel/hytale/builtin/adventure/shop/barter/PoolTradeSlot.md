---
description: Architectural reference for PoolTradeSlot
---

# PoolTradeSlot

**Package:** com.hypixel.hytale.builtin.adventure.shop.barter
**Type:** Data Model / Component

## Definition
```java
// Signature
public class PoolTradeSlot extends TradeSlot {
```

## Architecture & Concepts
The PoolTradeSlot is a specialized implementation of the abstract TradeSlot contract. Its primary architectural role is to serve as a dynamic, randomized trade generator for in-game bartering systems. This component is fundamental to creating non-static NPC shops and loot tables, enhancing replayability.

Unlike a fixed list of trades, a PoolTradeSlot is defined by a collection of potential WeightedTrade objects. At runtime, when a list of trades is required—for example, when a player opens a shop interface—the PoolTradeSlot's resolve method is invoked. This method performs a weighted random selection *without replacement* from the configured pool to generate a concrete, temporary list of BarterTrade objects.

The presence of a static CODEC field is a critical architectural indicator. It signifies that PoolTradeSlot instances are designed to be deserialized from data files (e.g., JSON assets) by the engine's content loading system. This decouples game logic from content design, allowing designers to define complex, randomized shop inventories without modifying source code.

## Lifecycle & Ownership
-   **Creation:** Instances are almost exclusively created by the Hytale Codec system during the asset loading phase. A game designer defines a PoolTradeSlot in a data file, and the engine instantiates the object when that asset is loaded into memory. Direct programmatic instantiation is possible but circumvents the intended data-driven workflow.
-   **Scope:** The lifetime of a PoolTradeSlot instance is bound to its containing asset, typically a larger configuration object like a Shop or a BarterTable. It persists in memory as long as that parent asset is loaded. The object itself represents a *template*; the `List<BarterTrade>` it generates is ephemeral and typically scoped to a single user interaction.
-   **Destruction:** The object is marked for garbage collection when its parent asset is unloaded. It does not manage any native resources and has no explicit destruction or cleanup method.

## Internal State & Concurrency
-   **State:** The internal state, consisting of `slotCount` and the `trades` array, is **effectively immutable** post-deserialization. The component is designed as a read-only data container after its initial creation. It holds no runtime state related to player interaction or inventory; it is purely a definition.
-   **Thread Safety:** This class is **not thread-safe** and must not be accessed concurrently without external synchronization. The `resolve` method's logic depends on an externally provided `Random` instance, which is inherently not thread-safe. Furthermore, the internal selection logic modifies a temporary list, which is not safe for concurrent execution. The intended usage pattern is for all invocations to occur on the main game logic thread.

## API Surface
The public API provides the core functionality for resolving the trade pool and inspecting its configuration.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| resolve(Random random) | List<BarterTrade> | O(N\*M) | The primary operational method. Generates a list of trades by performing N weighted random selections from a pool of M trades. Returns a new list on each invocation. |
| getSlotCount() | int | O(1) | Returns the maximum number of trades that will be generated by the resolve method. |
| getTrades() | WeightedTrade[] | O(1) | Returns the underlying array of all possible trades in the pool. **Warning:** This array should be treated as read-only. |

## Integration Patterns

### Standard Usage
The component is intended to be held by a higher-level manager system. This manager invokes `resolve` at the appropriate time (e.g., a shop UI opening) to populate the interface with a fresh set of trades.

```java
// Assume 'shopDefinition' is an object loaded from game assets
// that contains a PoolTradeSlot.
PoolTradeSlot tradePool = shopDefinition.getTradeSlot();

// 'worldRandom' is the appropriate Random instance for this context.
List<BarterTrade> currentTrades = tradePool.resolve(worldRandom);

// The UI system now uses 'currentTrades' to display options to the player.
shopUI.displayTrades(currentTrades);
```

### Anti-Patterns (Do NOT do this)
-   **Runtime Modification:** Do not retrieve the `trades` array via `getTrades` and modify its contents. This corrupts the base definition for all subsequent calls to `resolve` and can lead to unpredictable game behavior.
-   **Shared Random Instance Across Threads:** Do not call the `resolve` method from multiple threads using the same `Random` instance. This will produce non-deterministic and incorrect selections.
-   **Caching Resolved Lists:** The purpose of this class is to provide dynamic results. Caching the list returned by `resolve` for long periods defeats its purpose, effectively turning it into a static trade list.

## Data Pipeline
The PoolTradeSlot acts as a transformation step between static data definition and dynamic game state.

> Flow:
> Game Asset (JSON) -> Codec Deserializer -> **PoolTradeSlot Instance** -> `resolve()` Invocation -> `List<BarterTrade>` -> Barter UI System -> Rendered to Player


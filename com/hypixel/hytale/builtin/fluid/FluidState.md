---
description: Architectural reference for FluidState
---

# FluidState

**Package:** com.hypixel.hytale.builtin.fluid
**Type:** Value Object / Data Structure

## Definition
```java
// Signature
public record FluidState(int fluidLevel, byte verticalFill) {
```

## Architecture & Concepts
FluidState is an immutable data record that represents the physical state of a single fluid block within the game world. It is a fundamental component of the fluid simulation system, designed for extreme performance through pre-computation and the Flyweight design pattern.

The core concept is to encapsulate two key properties of a fluid block:
*   **fluidLevel:** An integer representing the horizontal flow distance from a source block. A value of 0, defined by SOURCE_LEVEL, indicates a source block itself. Higher values signify that the fluid has flowed further away from its source, which typically corresponds to a lower volume or pressure.
*   **verticalFill:** A byte representing the vertical height of the fluid within the block. A value of 8, defined by FULL_LEVEL, indicates the block is completely full.

A static array, FLUID_STATES, is pre-populated at class-loading time. This array serves as a canonical cache of all common fluid states. The fluid simulation engine is designed to retrieve instances from this cache rather than instantiating new objects during runtime, drastically reducing memory allocation and garbage collection overhead.

## Lifecycle & Ownership
- **Creation:** The primary set of FluidState instances is created once, when the class is loaded by the JVM. The static `generateFluidStates` method is invoked to populate the FLUID_STATES cache. Transient, non-canonical instances can be created using the constructor, but this is strongly discouraged in performance-critical code.
- **Scope:** Instances within the static FLUID_STATES cache are application-scoped. They persist for the entire lifetime of the game session.
- **Destruction:** The cached instances are eligible for garbage collection only when the FluidState class is unloaded, which typically occurs at application shutdown.

## Internal State & Concurrency
- **State:** **Immutable**. As a Java record, a FluidState object's fields are final. Once an instance is created, its state cannot be modified. The static FLUID_STATES array is also effectively immutable after its initial population.
- **Thread Safety:** **Fully thread-safe**. Due to its immutability, a FluidState instance can be safely shared and read by multiple threads without any need for external synchronization or locks. This is critical for parallelized world-generation or physics-ticking systems.

## API Surface
The public API is minimal, reflecting its role as a simple data carrier. Accessor methods `fluidLevel()` and `verticalFill()` are implicitly generated by the record.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| generateFluidStates(maxLevel) | static FluidState[] | O(N) | **Internal Engine Use Only.** Factory method to generate the canonical cache of fluid states. |
| toString() | String | O(1) | Provides a human-readable string representation for debugging purposes. |

## Integration Patterns

### Standard Usage
The correct pattern is to treat FluidState as a value retrieved from the canonical cache. The fluid simulation engine calculates the desired level and fill, then uses those values to look up the corresponding pre-existing object.

**WARNING:** Direct instantiation within the game loop is a severe performance anti-pattern.

```java
// Correct: Retrieve a canonical, pre-allocated instance
// (Conceptual example, actual lookup may differ)
int calculatedLevel = 3;
int calculatedFill = 5;
int stateIndex = calculateStateIndex(calculatedLevel, calculatedFill);
FluidState currentState = FluidState.FLUID_STATES[stateIndex];

// Use the state for rendering or physics
world.setBlockFluidState(position, currentState);
```

### Anti-Patterns (Do NOT do this)
- **Direct Instantiation:** Avoid calling `new FluidState()` in any performance-sensitive code, such as the main game loop or world update ticks. This defeats the purpose of the static cache and will cause significant GC pressure.

    ```java
    // ANTI-PATTERN: Creates unnecessary garbage
    for (Block b : updatedBlocks) {
        // This creates a new object every single time
        FluidState newState = new FluidState(3, 5);
        b.setFluidState(newState);
    }
    ```

## Data Pipeline
FluidState does not process data; it *is* the data. It serves as an immutable payload that flows from the physics simulation to other engine systems like world storage and rendering.

> Flow:
> Fluid Simulation Engine -> **FluidState.FLUID_STATES** (Cache Lookup) -> World Chunk Data -> Rendering Engine (Mesh Generation)


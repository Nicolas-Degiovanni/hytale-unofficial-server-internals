---
description: Architectural reference for VerticalEliminatorPositionProvider
---

# VerticalEliminatorPositionProvider

**Package:** com.hypixel.hytale.builtin.hytalegenerator.positionproviders
**Type:** Transient

## Definition
```java
// Signature
public class VerticalEliminatorPositionProvider extends PositionProvider {
```

## Architecture & Concepts
The VerticalEliminatorPositionProvider is a component within the world generation system that acts as a compositional filter. It embodies the **Decorator** design pattern, wrapping another PositionProvider to add specific behavior without modifying the underlying provider.

Its sole function is to constrain the vertical placement of world features. It intercepts the stream of coordinates generated by its wrapped child provider and discards any positions that fall outside a predefined Y-axis range. This allows world generation logic to be built in layers: a base provider can generate positions across all altitudes, and a VerticalEliminatorPositionProvider can be layered on top to restrict those positions to a specific vertical slice, such as underground caves or mountaintops.

This class is a fundamental building block for creating complex and layered world generation rules through composition rather than inheritance.

### Lifecycle & Ownership
- **Creation:** Instantiated directly via its constructor, typically during the assembly of a world generation pipeline for a specific biome or feature. It is not managed by a dependency injection framework.
- **Scope:** The object's lifetime is tied to the parent configuration that created it. It is generally short-lived, existing only for the duration of a specific generation task (e.g., placing ores in a single chunk).
- **Destruction:** The object is managed by the Java garbage collector. It becomes eligible for collection as soon as the world generation task completes and the reference to the provider chain is dropped.

## Internal State & Concurrency
- **State:** The internal state consists of the `minY`, `maxY`, and the wrapped `positionProvider`. These are all `final` fields, making the object's configuration **immutable** after construction. The class does not cache results or maintain any mutable state between calls.
- **Thread Safety:** This class is inherently **thread-safe**. Its immutable state and the operational pattern of creating a new, non-shared context for each call to `positionsIn` prevent race conditions. It is safe to use a single instance of this provider across multiple threads simultaneously, a common scenario in parallelized chunk generation.

## API Surface

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| positionsIn(Context context) | void | O(N) | Intercepts positions from a wrapped provider. For each position, it performs an O(1) check against its vertical bounds. N is the number of positions from the child. |

## Integration Patterns

### Standard Usage
The class is designed to be chained with other providers. A base provider generates candidate positions, and the VerticalEliminatorPositionProvider filters them.

```java
// 1. Define a base provider that generates positions everywhere.
PositionProvider baseProvider = new RandomPositionsInChunkProvider();

// 2. Wrap the base provider to filter for positions between Y=10 and Y=50.
PositionProvider undergroundProvider = new VerticalEliminatorPositionProvider(10, 50, baseProvider);

// 3. The world generator uses the wrapped provider.
//    Only positions with 10 <= y < 50 will be processed.
worldGenerator.placeFeaturesUsing(undergroundProvider);
```

### Anti-Patterns (Do NOT do this)
- **Invalid Range:** Constructing with `minY >= maxY` will create a filter that rejects all positions. This is a logical error and will silently prevent any features from generating, which can be difficult to debug.
- **Redundant Nesting:** Chaining multiple VerticalEliminatorPositionProviders is inefficient and indicative of poor configuration. The outermost filter's constraints will render any inner filters with wider ranges completely redundant.

## Data Pipeline
The data flow is a classic example of delegation with an interception layer. The key mechanism is the replacement of the consumer function within a temporary context.

> Flow:
> 1. `positionsIn` is invoked on a VerticalEliminatorPositionProvider instance with an initial `Context`.
> 2. A new `childContext` is created, inheriting from the initial context.
> 3. The `consumer` of the `childContext` is replaced with a new lambda function. This lambda contains the filtering logic.
> 4. The `positionsIn` method of the wrapped `positionProvider` is called with the `childContext`.
> 5. The wrapped provider generates positions and passes them to the filtering lambda.
> 6. The lambda checks if `position.y` is within the `[minY, maxY)` range.
> 7. If the check passes, the position is forwarded to the *original* consumer from the initial `Context`. If it fails, the position is discarded.


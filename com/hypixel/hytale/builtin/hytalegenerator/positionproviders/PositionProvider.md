---
description: Architectural reference for PositionProvider
---

# PositionProvider

**Package:** com.hypixel.hytale.builtin.hytalegenerator.positionproviders
**Type:** Strategy Interface

## Definition
```java
// Signature
public abstract class PositionProvider {
```

## Architecture & Concepts
The **PositionProvider** is a foundational component of the procedural world generation system. It embodies the **Strategy Pattern**, defining a contract for algorithms that generate sets of 3D coordinates within a specified volume. Its primary role is to decouple the logic of *what* to place (e.g., trees, ores, structures) from the logic of *where* to place it.

Concrete implementations of this class determine the spatial distribution of world features. For example, a **GridPositionProvider** might generate evenly spaced points, while a **RandomPositionProvider** would generate scattered points based on a noise function.

The entire operation is driven by the **PositionProvider.Context** object, which acts as a parameter object containing all necessary information for a single generation request:
*   A bounding volume (**minInclusive**, **maxExclusive**).
*   A **Consumer** callback to receive the generated positions.
*   A **workerId**, which is critical for deterministic and partition-aware generation in a multi-threaded environment.

This design ensures that position generation can be parallelized safely across multiple worker threads, as each worker operates on a distinct context.

## Lifecycle & Ownership
- **Creation:** **PositionProvider** instances are not managed services. They are typically instantiated and configured as part of a larger world generation feature's definition, often deserialized from configuration files (e.g., JSON). They represent a piece of configuration data.
- **Scope:** The lifetime of a **PositionProvider** is tied to the world generator feature that owns it. These objects are intended to be lightweight and are often created, used for a generation pass, and then become eligible for garbage collection.
- **Destruction:** Managed entirely by the Java Garbage Collector. There is no explicit cleanup or shutdown method.

## Internal State & Concurrency
- **State:** The abstract **PositionProvider** is stateless. Concrete implementations **must** be designed to be stateless and immutable. All parameters required for an operation are passed via the **PositionProvider.Context** object. Storing mutable state within a provider instance is a severe anti-pattern that will break determinism and thread safety.
- **Thread Safety:** This class is designed for high-concurrency environments. The stateless nature of provider instances makes them inherently thread-safe. The `positionsIn` method can be called simultaneously by multiple world generation workers without interference, provided each call uses a distinct **Context** instance. The responsibility for handling concurrent writes lies with the supplied **Consumer**.

## API Surface

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| positionsIn(Context context) | void | Varies | **Core Method.** Abstract contract for implementations to generate positions within the given context and feed them to the context's consumer. |
| noPositionProvider() | PositionProvider | O(1) | **Static Factory.** Returns a singleton, no-op implementation. This is an application of the Null Object Pattern to prevent null checks in generator code. |

## Integration Patterns

### Standard Usage
A **PositionProvider** is used by a higher-level generator system, such as a Feature Placer, to determine placement locations. The caller is responsible for constructing the context and providing a consumer to process the results.

```java
// In a hypothetical FeaturePlacer class
PositionProvider treePositions = new ClusteredRandomPositionProvider(seed, density);
WorkerIndexer.Id workerId = worldGenContext.getWorkerId();

// Create a context for the current chunk and worker
PositionProvider.Context context = new PositionProvider.Context(
    chunk.getMin(),
    chunk.getMax(),
    position -> world.placeTree(position), // The consumer places a tree
    chunk.getCenter(),
    workerId
);

// Execute the position generation algorithm
treePositions.positionsIn(context);
```

### Anti-Patterns (Do NOT do this)
- **Stateful Implementations:** Do not add mutable fields to a **PositionProvider** subclass. This will cause race conditions and non-deterministic output when used by multiple worker threads.
- **Ignoring Worker ID:** Implementations that need to use random numbers or partitioned algorithms must use the **workerId** from the context to ensure that each thread produces a unique, deterministic subset of the total result. Ignoring it can lead to identical or overlapping features being generated by different threads.
- **Blocking Consumers:** The **Consumer** provided in the context should be non-blocking or execute very quickly. The `positionsIn` method is often synchronous; a slow consumer will stall the world generation worker thread.

## Data Pipeline
The **PositionProvider** acts as a data source in a localized generation pipeline. It does not receive data from a stream but rather initiates a flow of position data based on its configuration.

> Flow:
> World Generator Feature -> Constructs **PositionProvider.Context** -> **PositionProvider.positionsIn()** -> Invokes Consumer Callback -> Feature Placement Logic


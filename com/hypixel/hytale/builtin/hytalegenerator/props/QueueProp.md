---
description: Architectural reference for QueueProp
---

# QueueProp

**Package:** com.hypixel.hytale.builtin.hytalegenerator.props
**Type:** Stateful Component

## Definition
```java
// Signature
public class QueueProp extends Prop {
```

## Architecture & Concepts

The QueueProp class implements a composite or "chain of responsibility" pattern for world generation props. It acts as a container for an ordered list of other Prop objects, treating the entire collection as a single, logical Prop.

Its primary function is to attempt to place props sequentially. During the `scan` phase of world generation, it iterates through its internal list of props, calling `scan` on each one. The moment a child Prop returns a positive ScanResult, the iteration stops, and that successful result is returned. This establishes a priority system: props earlier in the list are attempted first.

This component is critical for creating varied and logical environmental features. For example, a generator might define a QueueProp to first attempt placing a large, rare feature. If the conditions are not met, it falls back to a more common, smaller feature, and so on, preventing empty space and creating a natural-looking distribution of assets.

Internally, QueueProp pre-calculates the total spatial footprint required by its child props. It determines the maximum read and write ranges from all contained props to compute a single, aggregate ContextDependency. This allows the world generation scheduler (StagedConveyor) to correctly allocate regions and manage data dependencies for the entire queue as one atomic operation, which is essential for parallelized world generation.

## Lifecycle & Ownership

-   **Creation:** An instance is created directly via its constructor: `new QueueProp(List<Prop> propsQueue)`. It is typically instantiated by higher-level generator configuration code that defines the procedural logic for a specific biome or feature set. It is not managed by a dependency injection container.
-   **Scope:** The object's lifetime is bound to the configuration that created it. It is a data-centric object that persists as long as the generation ruleset it belongs to is active.
-   **Destruction:** The instance is eligible for garbage collection once all references to it are released, typically after a world generation task is complete and its configuration is no longer needed.

## Internal State & Concurrency

-   **State:** QueueProp is stateful but effectively immutable after construction. The constructor creates a defensive copy of the incoming prop list and calculates the aggregate bounds and dependencies, which are stored in final fields. The internal state is not modified during its operational lifecycle.
-   **Thread Safety:** This class is conditionally thread-safe. Its methods do not modify internal state and can be safely called from multiple worker threads, which is a common pattern in the Hytale generator. Thread safety is contingent on the thread-safety of the objects passed into its methods, such as the VoxelSpace. The presence of the WorkerIndexer.Id parameter in the `scan` method signature is a strong indicator that this class is designed for concurrent execution.

## API Surface

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| scan(position, materialSpace, id) | ScanResult | O(N) | Iterates the internal prop queue of size N, returning the first positive result. |
| place(context) | void | O(1) | Delegates the place operation to the successful prop identified in the scan phase. |
| getContextDependency() | ContextDependency | O(1) | Returns a clone of the pre-calculated aggregate dependency information. |
| getWriteBounds() | Bounds3i | O(1) | Returns the pre-calculated maximum bounds that this queue can modify. |

## Integration Patterns

### Standard Usage

QueueProp is used to define a prioritized sequence of world features. The developer populates a list with different Prop implementations and passes it to the QueueProp constructor. This composite prop is then used by the generation system.

```java
// How a developer should normally use this
List<Prop> forestFeatures = new ArrayList<>();
forestFeatures.add(new LargeOakTreeProp());   // Try this first
forestFeatures.add(new SmallBirchTreeProp()); // Fallback
forestFeatures.add(new BushProp());           // Final fallback

// The queue is treated as a single prop by the generator
Prop prioritizedForestProp = new QueueProp(forestFeatures);

// The generator would then use this prop
generator.addFeature(prioritizedForestProp);
```

### Anti-Patterns (Do NOT do this)

-   **Incorrect ScanResult Context:** Do not call `place` with a ScanResult that was not generated by the `scan` method of the *same* QueueProp instance. The internal `QueueScanResult.cast` method will throw an IllegalArgumentException to prevent this data corruption.
-   **Inefficient Ordering:** Placing computationally expensive or rarely successful props at the beginning of the queue can severely degrade generator performance. The list should be ordered by priority, but with performance characteristics in mind.
-   **Stateful Child Props:** While QueueProp itself is immutable after construction, it offers no protection if the contained Prop objects are stateful and not thread-safe. All props within the queue must be designed for concurrent execution.

## Data Pipeline

The primary flow involves checking a sequence of conditions until one is met, and then acting upon it.

> Flow:
> Generator Configuration -> **new QueueProp(List<Prop>)** -> StagedConveyor invokes `scan` -> **QueueProp** iterates children -> Child Prop returns positive ScanResult -> **QueueProp** wraps result in QueueScanResult -> StagedConveyor invokes `place` -> **QueueProp** unwraps result and delegates to the successful Child Prop -> VoxelSpace is modified


---
description: Architectural reference for AmplitudeConstantDensity
---

# AmplitudeConstantDensity

**Package:** com.hypixel.hytale.builtin.hytalegenerator.density.nodes
**Type:** Transient Component

## Definition
```java
// Signature
public class AmplitudeConstantDensity extends Density {
```

## Architecture & Concepts
The AmplitudeConstantDensity class is a fundamental operator node within the procedural world generation's *Density Graph* system. It performs a single, critical mathematical operation: **scalar multiplication**.

Its primary role is to take the output value from an upstream Density node (the *input*) and scale it by a pre-configured constant factor (the *amplitude*). This allows world designers to control the magnitude, intensity, or influence of any procedural signal. For example, it can be used to increase the height of mountains generated by a noise function, deepen a river valley, or strengthen the blending factor for a specific biome.

Architecturally, it is designed to be a simple, composable link in a complex chain of operations. It is a non-terminal node in a directed acyclic graph (DAG) of Density objects, where each node contributes to a final value that might represent terrain height, cave systems, or material distribution.

## Lifecycle & Ownership
- **Creation:** Instances are not typically created manually in game logic. They are instantiated by the Hytale Generator framework during the parsing and assembly of a world generation graph, usually defined in an external asset file like JSON.
- **Scope:** The lifetime of an AmplitudeConstantDensity object is strictly tied to the parent Density Graph that contains it. It persists as long as the world generator configuration is loaded and required for a generation task.
- **Destruction:** The object is eligible for garbage collection once the parent Density Graph is discarded. This occurs when a generation task is complete and its results are finalized, or when the server unloads the world generator configuration. There is no explicit destruction or cleanup method.

## Internal State & Concurrency
- **State:** The internal state is **conditionally mutable**.
    - The `amplitude` field is `final`, making it immutable after construction. This ensures the scaling factor is consistent for the lifetime of the node.
    - The `input` field, which references the upstream Density node, is mutable and can be reassigned post-construction via the `setInputs` method. This allows for dynamic reconfiguration of the Density Graph, though this is an advanced and potentially hazardous operation.

- **Thread Safety:** This class is **not thread-safe**. The mutable `input` field creates a significant potential for race conditions. Modifying the graph structure via `setInputs` from one thread while another thread executes `process` will lead to inconsistent and unpredictable world generation.

    **WARNING:** The entire Density Graph is considered a single-threaded structure during modification. All structural changes must be completed before the graph is handed off to multi-threaded world generation workers for processing. The `process` method itself is re-entrant and safe for concurrent execution only if the graph's structure remains static.

## API Surface

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| process(Context context) | double | O(N) | Recursively processes the input node and multiplies its result by the internal amplitude. N is the depth of the subgraph. Returns 0.0 if no input is connected. |
| setInputs(Density[] inputs) | void | O(1) | Replaces the current input node. If the array is empty, the input is set to null. If it contains one or more elements, only the first is used. |

## Integration Patterns

### Standard Usage
This class is never used in isolation. It is always composed into a larger graph of Density nodes to modify a signal.

```java
// The following is a conceptual illustration of graph construction.
// Direct instantiation is typically handled by the generator framework.

// 1. Define a base signal, like Perlin noise.
Density baseNoise = new PerlinNoiseDensity(/* ... */);

// 2. Define the desired amplitude (e.g., for mountain height).
double mountainAmplitude = 120.0;

// 3. Create the AmplitudeConstantDensity node to scale the base signal.
Density amplifiedNoise = new AmplitudeConstantDensity(mountainAmplitude, baseNoise);

// 4. The 'amplifiedNoise' node is now used by other parts of the
//    world generator to produce tall terrain features.
double finalValue = amplifiedNoise.process(generationContext);
```

### Anti-Patterns (Do NOT do this)
- **Dynamic Re-Parenting:** Avoid calling `setInputs` on a node that is part of an active Density Graph currently being processed by worker threads. This will break thread safety guarantees.
- **Cyclical Graphs:** Constructing a graph where a node can trace a path back to itself (e.g., `nodeA.setInput(nodeB)` and `nodeB.setInput(nodeA)`) is a critical error. This will cause a StackOverflowError during the `process` call. All Density Graphs must be DAGs.

## Data Pipeline
The flow of data through this component is linear and unidirectional. It acts as a simple transformation step in a larger pipeline.

> Flow:
> Upstream Density Node -> `process()` -> **AmplitudeConstantDensity** -> (Result is multiplied by `amplitude`) -> Downstream Consumer (Another Density node or final terrain composer)


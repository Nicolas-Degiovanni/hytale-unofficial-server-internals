---
description: Architectural reference for FieldFunctionAssignments
---

# FieldFunctionAssignments

**Package:** com.hypixel.hytale.builtin.hytalegenerator.propdistributions
**Type:** Strategy / Data Object

## Definition
```java
// Signature
public class FieldFunctionAssignments extends Assignments {
```

## Architecture & Concepts
The FieldFunctionAssignments class is a fundamental component within the procedural world generation engine, responsible for prop placement logic. It functions as a conditional dispatcher, translating a continuous scalar value from a density field into a specific prop selection strategy.

At its core, this class implements a "switch-on-a-range" pattern. It takes a complex mathematical function, represented by the Density object, which can be any combination of noise functions like Perlin or Simplex, mathematical operations, and coordinate transformations. For any given 3D point in the world, it evaluates this Density function to produce a single floating-point number.

This number is then compared against a list of non-overlapping ranges defined by FieldDelimiter objects. Each range is mapped to another, more specific Assignments object. This creates a powerful, data-driven hierarchy for prop generation.

For example, a Density function could represent elevation. FieldFunctionAssignments could then use this elevation value to delegate prop selection:
*   Values from 0.0 to 0.2 might delegate to a `BeachProps` Assignments object (placing driftwood, shells).
*   Values from 0.2 to 0.6 might delegate to a `ForestProps` Assignments object (placing trees, bushes).
*   Values from 0.6 to 1.0 might delegate to a `MountainProps` Assignments object (placing rocks, sparse pines).

This mechanism allows world generation designers to create rich, varied environments by layering functions and rules without writing new code.

## Lifecycle & Ownership
-   **Creation:** This object is not intended for manual instantiation in game logic. It is constructed by a higher-level configuration loader when parsing world generation asset files (e.g., biome definitions in JSON). The `Density` function and the list of `FieldDelimiter`s are provided declaratively in these assets.
-   **Scope:** An instance of FieldFunctionAssignments is immutable and its lifetime is bound to the loaded world generation configuration. It persists as long as the biome or zone definition it belongs to is active.
-   **Destruction:** The object is marked for garbage collection when the server or client unloads the corresponding world generation assets, typically during a world change or shutdown.

## Internal State & Concurrency
-   **State:** This class is **effectively immutable**. Its core fields, `density` and `fieldDelimiters`, are marked as final. The constructor defensively copies the incoming list of delimiters into a new ArrayList, preventing any external modifications to the list after instantiation.
-   **Thread Safety:** FieldFunctionAssignments is **thread-safe** and designed for high-concurrency access from multiple world generation worker threads. The primary method, `propAt`, is a pure function with no side effects or reliance on shared mutable state. A new `Density.Context` is allocated on the stack for each call, ensuring no data races between threads.

    **Warning:** The overall thread safety of a generation pass depends on the provided `Density` function and all nested `Assignments` objects also being thread-safe. This class itself introduces no concurrency hazards.

## API Surface

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| propAt(position, id, distance) | Prop | O(N) | Evaluates the density function at the given position and delegates to the first matching delimiter's `Assignments` object. N is the number of delimiters. |
| getRuntime() | int | O(1) | Returns the configured runtime identifier for this assignment set. |
| getAllPossibleProps() | List<Prop> | O(N * M) | Recursively collects and returns a list of all props that could possibly be generated by this object and its children. N is the number of delimiters, and M is the average number of props in child assignments. |

## Integration Patterns

### Standard Usage
This class is typically defined within a world generation configuration file and used implicitly by the engine. A developer would not interact with it directly. The example below shows a conceptual representation of how it would be configured.

```java
// Conceptual Usage by the World Generation Engine
// This code is not meant to be written by users.

// 1. Configuration is loaded from a file.
Density elevationFunc = loadDensityFunction("world/elevation.json");
List<FieldDelimiter> delimiters = List.of(
    new FieldDelimiter(forestAssignments, 0.2, 0.6),
    new FieldDelimiter(mountainAssignments, 0.6, 1.0)
);

// 2. The object is created by the engine.
Assignments propStrategy = new FieldFunctionAssignments(elevationFunc, delimiters, 0);

// 3. The engine invokes it for a specific block column.
Vector3d targetPosition = new Vector3d(100, 64, 250);
WorkerIndexer.Id workerId = ...;
Prop chosenProp = propStrategy.propAt(targetPosition, workerId, 0.0);
```

### Anti-Patterns (Do NOT do this)
-   **Direct Instantiation:** Never create this object manually using `new FieldFunctionAssignments()`. It is designed to be data-driven and configured by the asset loading pipeline. Manual creation bypasses caching and validation.
-   **Overlapping Delimiters:** The system performs a linear scan of delimiters and uses the *first* one that matches. Defining overlapping ranges (e.g., `[0.2, 0.6)` and `[0.5, 0.8)`) will lead to unpredictable behavior that depends entirely on the order of the delimiters in the list. Ranges should be contiguous and non-overlapping.
-   **Excessive Delimiter Chains:** While powerful, a long, flat list of delimiters in a single FieldFunctionAssignments object will result in a linear search for every `propAt` call. For high-granularity selections, consider nesting FieldFunctionAssignments objects to create a more tree-like evaluation structure, which can be more performant and easier to reason about.

## Data Pipeline
The data flow for a single prop selection is a clear, multi-stage process that transforms a spatial coordinate into a final game object.

> Flow:
> Vector3d position -> Density.process() -> double fieldValue -> **FieldFunctionAssignments** (Selects delegate based on fieldValue) -> Nested Assignments.propAt() -> Prop instance


---
description: Architectural reference for NStagedChunkGenerator
---

# NStagedChunkGenerator

**Package:** com.hypixel.hytale.builtin.hytalegenerator.newsystem
**Type:** Configured Service

## Definition
```java
// Signature
public class NStagedChunkGenerator implements ChunkGenerator {
```

## Architecture & Concepts

The NStagedChunkGenerator is the central orchestrator for Hytale's modern, data-oriented procedural world generation system. It implements the engine's standard **ChunkGenerator** interface, but its internal design is a sophisticated, multi-stage pipeline optimized for high throughput and parallelism.

Its core architectural principles are:

1.  **Staged Execution:** World generation is not a monolithic function. Instead, it is broken down into a sequence of discrete, dependent steps called **NStage** objects. Each stage is responsible for a specific aspect of generation, such as heightmap creation, biome placement, cave carving, or structure spawning.
2.  **Data-Oriented Design:** The generator operates on large, contiguous blocks of memory called buffers, managed by a central **NBufferBundle**. Stages do not operate on the final chunk data structures directly. Instead, they read from input buffers and write to output buffers. This separation of data and logic allows for aggressive caching, efficient memory access, and simplified parallel processing.
3.  **Dependency Graph:** The generator, via its **Builder**, analyzes the input and output buffer types of each stage to construct an implicit dependency graph. This allows it to calculate the total required data footprint for any given stage, ensuring that when a stage runs, all its prerequisite data has already been generated by prior stages.
4.  **Massive Parallelism:** The generation of a single chunk is parallelized at multiple levels. The work is divided into vertical columns (tiles), and tasks for generating these columns are distributed across a worker thread pool managed by an **ExecutorService**. Final data transfer from the intermediate buffers to the engine's native **GeneratedChunk** format is also performed asynchronously using **CompletableFuture**.

This class acts as the bridge between the high-level request for a chunk from the server's world system and the low-level, computationally intensive work performed by the individual generation stages.

### Lifecycle & Ownership
-   **Creation:** The NStagedChunkGenerator is exclusively instantiated via its inner **Builder** class. The private constructor prevents direct instantiation. The builder is responsible for configuring the sequence of stages, injecting dependencies like the **ExecutorService** and **MaterialCache**, and calculating the necessary buffer capacities based on server configuration (e.g., view distance, player count).
-   **Scope:** An instance of NStagedChunkGenerator is a long-lived service. Typically, one instance is created per world or dimension during server initialization and persists for the entire lifetime of that world. It is a heavy object to construct due to the buffer allocation and dependency analysis.
-   **Destruction:** The object is garbage collected when the world it belongs to is unloaded and all references are released. There is no explicit destroy or shutdown method.

## Internal State & Concurrency
-   **State:** The NStagedChunkGenerator holds significant mutable state. Its primary state components are:
    -   **stages**: An ordered array of **NStage** objects defining the generation pipeline. This is immutable after construction.
    -   **bufferBundle**: A reference to the **NBufferBundle**, which manages the lifecycle and memory of all intermediate generation data. This is a highly mutable and performance-critical component.
    -   **concurrentExecutor**: The thread pool used to execute all parallel generation tasks.
    -   **Performance Metrics**: Fields like **generatedChunkCount** and **timeInstrument** track performance and statistics for logging and diagnostics.

-   **Thread Safety:** The NStagedChunkGenerator is designed for concurrent use, but with specific constraints. The primary public method, **generate**, is internally thread-safe and non-blocking. It orchestrates a complex series of asynchronous operations.

    **WARNING:** While the **generate** method can be called by multiple threads to generate different chunks simultaneously, a single instance is not re-entrant for the *same chunk coordinates*. The internal logic relies on the **NBufferBundle** to cache and manage data, and concurrent requests for the same chunk would lead to unpredictable behavior. The system assumes a higher-level cache (like **ChunkProvider**) prevents duplicate concurrent requests.

    All computationally intensive work is delegated to worker threads via **CompletableFuture**, ensuring the calling thread is not blocked. The core logic within **generate** is responsible for task decomposition, dependency management, and final data aggregation.

## API Surface

The public API is minimal, primarily consisting of the contract from the **ChunkGenerator** interface and the configuration-focused **Builder**.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| generate(ChunkRequest.Arguments) | GeneratedChunk | O(N\*M) | The primary entry point. Orchestrates the entire multi-stage pipeline to generate a single chunk. N is the number of stages, M is the number of tiles. This is a non-blocking, highly parallel operation. |
| NStagedChunkGenerator.Builder | class | - | The sole mechanism for configuring and instantiating a generator. |

## Integration Patterns

### Standard Usage

The generator must be constructed and configured during server initialization using the **Builder** pattern. Dependencies like the thread pool and material cache are injected at this time.

```java
// Example of building a generator during server startup
ExecutorService worldGenExecutor = Executors.newFixedThreadPool(8);
WorkerIndexer workerIndexer = new WorkerIndexer(8);
MaterialCache materialCache = server.getMaterialCache();

NStagedChunkGenerator.Builder builder = new NStagedChunkGenerator.Builder()
    .withConcurrentExecutor(worldGenExecutor, workerIndexer)
    .withMaterialCache(materialCache)
    .withBufferCapacity(1.2, 20, 64) // factor, view distance, player count
    .withStats("Zone1-Generator", Set.of(100, 500, 1000));

// Stages are appended in execution order
builder.appendStage(new HeightmapStage());
builder.appendStage(new BiomeStage());
builder.appendStage(new CaveCarverStage());
// ... other stages

// The built instance is then registered with the world/dimension
NStagedChunkGenerator generator = builder.build();
world.setChunkGenerator(generator);
```

### Anti-Patterns (Do NOT do this)
-   **Misordered Stages:** Appending stages to the builder in an order that violates data dependencies will cause generation failures or incorrect world features. For example, placing a cave carver before the primary terrain noise stage.
-   **Stateful Stages:** Stages should be designed to be stateless. Relying on mutable fields within an **NStage** instance across multiple chunk generations is not thread-safe and will lead to race conditions and visual artifacts. All state should be passed via the **NStage.Context** and its buffers.
-   **Ignoring Builder Configuration:** Failing to configure the **Builder** with appropriate buffer capacities or a properly sized executor service will lead to severe performance degradation, memory exhaustion, or thread starvation.

## Data Pipeline

The data flow for a single call to **generate** is a complex orchestration of caching, parallel computation, and data transformation.

> Flow:
> **ChunkRequest** -> **generate()** -> Create **NBufferBundle.Access** -> For each **NStage**:
> 1. Identify uncached output columns (tiles).
> 2. Create parallel **Runnable** tasks for each uncached column.
> 3. Submit all tasks to **ExecutorService** via **CompletableFuture**.
> 4. *[In Worker Thread]*: Task reads from input buffers, performs computation, writes to output buffers within **NBufferBundle**.
> 5. **generate()** joins all **CompletableFuture**s for the stage.
>
> -> After all stages complete:
> 1. Launch asynchronous **transfer** methods (e.g., **transferMaterials**, **transferEntities**).
> 2. *[In Worker Thread]*: Transfer methods read final data from **NBufferBundle** buffers.
> 3. *[In Worker Thread]*: Data is copied and transformed into the engine-native **GeneratedChunk** format.
> 4. **generate()** joins all transfer futures.
>
> -> Return **GeneratedChunk**


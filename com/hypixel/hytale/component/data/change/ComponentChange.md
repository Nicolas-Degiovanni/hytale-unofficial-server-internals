---
description: Architectural reference for ComponentChange
---

# ComponentChange

**Package:** com.hypixel.hytale.component.data.change
**Type:** Value Object

## Definition
```java
// Signature
public class ComponentChange<ECS_TYPE, T extends Component<ECS_TYPE>> implements DataChange {
```

## Architecture & Concepts
The ComponentChange class is an immutable data carrier that represents a discrete change to an entity's component set within the Entity-Component-System (ECS) framework. It does not contain the component data itself, but rather the metadata about the event: the type of change (ADD or REMOVE) and the type of component affected.

This class is a fundamental primitive in Hytale's data synchronization and event propagation architecture. It serves as a message, created by the core ECS manager, to signal that an entity's composition has been altered. Systems that subscribe to these changes, such as the network replication layer or game logic event buses, consume these objects to react accordingly. Its design as a lightweight, immutable value object ensures it can be safely and efficiently passed between different engine subsystems and across thread boundaries.

## Lifecycle & Ownership
-   **Creation:** Instances are created exclusively by the core ECS state management systems when a component is added to or removed from an entity. For example, a call to an entity's addComponent method will trigger the instantiation of a corresponding ComponentChange object.
-   **Scope:** Transient and extremely short-lived. A ComponentChange object exists only for the duration of a single processing tick or event dispatch cycle. It is intended to be immediately consumed by a listener or placed into a queue for processing.
-   **Destruction:** The object is managed by the Java Garbage Collector. As it is a short-lived object with no persistent references, it is typically eligible for collection immediately after the event it represents has been fully processed. Holding long-term references to these objects is a critical anti-pattern that will result in memory leaks.

## Internal State & Concurrency
-   **State:** **Immutable**. All internal fields are declared as final and are initialized only once during construction. This guarantees that a ComponentChange object cannot be altered after its creation, which is critical for predictable state replication.
-   **Thread Safety:** **Inherently thread-safe**. Due to its immutable nature, an instance of ComponentChange can be safely read by multiple threads concurrently without any external synchronization or locking mechanisms. This allows it to be used in high-performance, multi-threaded contexts such as parallel game logic updates or asynchronous network serialization.

## API Surface
The public contract is minimal, providing read-only access to the change metadata.

| Symbol | Type | Complexity | Description |
| :--- | :--- | :--- | :--- |
| getType() | ChangeType | O(1) | Returns the type of change that occurred (e.g., ADD, REMOVE). |
| getComponentType() | ComponentType | O(1) | Returns the metadata object for the component type that was affected by the change. |

## Integration Patterns

### Standard Usage
ComponentChange objects are not intended to be created by gameplay developers. Instead, they are received and processed by systems that listen for ECS state modifications.

```java
// Example of a hypothetical system processing a queue of data changes
public void processChanges(List<DataChange> changes) {
    for (DataChange change : changes) {
        if (change instanceof ComponentChange) {
            ComponentChange<?, ?> componentChange = (ComponentChange<?, ?>) change;

            if (componentChange.getType() == ChangeType.ADD) {
                // Logic to handle a new component being added to an entity
                System.out.println("Component added: " + componentChange.getComponentType().getName());
            }
        }
    }
}
```

### Anti-Patterns (Do NOT do this)
-   **Direct Instantiation:** Never create instances using `new ComponentChange()`. These events must be generated by the authoritative ECS manager to ensure data integrity. Manually creating these objects can desynchronize game state.
-   **State Caching:** Do not store ComponentChange objects for longer than a single frame or processing cycle. They represent a point-in-time event and should be processed and discarded immediately. Caching them is a memory leak.
-   **Type Assumption:** Do not assume the generic types without a proper system-level contract. Always handle the change based on the provided ComponentType metadata.

## Data Pipeline
ComponentChange acts as a message that flows from the core game state into various reactive subsystems.

> Flow:
> Game Logic Action -> ECS State Manager -> **ComponentChange** Instantiation -> Event Bus / ChangeSet -> Network Replication System or Local Game System<ctrl63>

